// This file was generated by Peginator v0.6.0 built at 1669796426
// CRC-32/ISO-HDLC of the grammar file: 9676314c
// Any changes to it will be lost on regeneration

#[derive(Debug, Clone)]
pub struct SahaParser {
    pub parsed: SahaStatementNodes,
}
#[derive(Debug, Clone)]
pub struct SahaStatementNodes {
    pub statements: Vec<SahaStatement>,
}
#[allow(non_camel_case_types)]
#[derive(Debug, Clone)]
pub enum SahaStatement {
    SlotExpressionNode(SlotExpressionNode),
    SlotFor(SlotFor),
    SlotIf(SlotIf),
    UnicodeText(UnicodeText),
}
#[derive(Debug, Clone)]
pub struct SlotIf {
    pub start: SlotIfStart,
    pub body: SahaStatementNodes,
    pub else_if: Vec<SlotElseIf>,
    pub r#else: Option<SlotElse>,
    pub end: SlotEndIf,
    pub position: std::ops::Range<usize>,
}
#[derive(Debug, Clone)]
pub struct SlotIfStart {
    pub left: SlotL,
    pub cond: ExpressionNode,
    pub right: SlotR,
}
#[derive(Debug, Clone)]
pub struct SlotElseIf {
    pub left: SlotL,
    pub cond: ExpressionNode,
    pub right: SlotR,
    pub body: SahaStatementNodes,
}
#[derive(Debug, Clone)]
pub struct SlotElse {
    pub left: SlotL,
    pub right: SlotR,
    pub body: SahaStatementNodes,
}
#[derive(Debug, Clone)]
pub struct SlotEndIf {
    pub left: SlotL,
    pub right: SlotR,
}
#[derive(Debug, Clone)]
pub struct EndIf;
#[derive(Debug, Clone)]
pub struct SlotFor {
    pub start: SlotForStart,
    pub body: SahaStatementNodes,
    pub r#else: Option<SlotElse>,
    pub end: SlotEndFor,
    pub position: std::ops::Range<usize>,
}
#[derive(Debug, Clone)]
pub struct SlotForStart {
    pub left: SlotL,
    pub pattern: ValueNode,
    pub expression: ExpressionNode,
    pub right: SlotR,
}
#[derive(Debug, Clone)]
pub struct SlotEndFor {
    pub left: SlotL,
    pub right: SlotR,
}
#[derive(Debug, Clone)]
pub struct EndFor;
#[derive(Debug, Clone)]
pub struct SlotExpressionNode {
    pub left: SlotL,
    pub e: ExpressionNode,
    pub right: SlotR,
}
#[derive(Debug, Clone)]
pub struct ExpressionNode {
    pub head: TermNode,
    pub infix: Vec<ExpressionNodeInfix>,
    pub position: std::ops::Range<usize>,
}
#[derive(Debug, Clone)]
pub struct ExpressionNodeInfix {
    pub op: InfixOp,
    pub value: TermNode,
}
#[derive(Debug, Clone)]
pub struct TermNode {
    pub prefix: Vec<PrefixOp>,
    pub term: ValueNode,
    pub suffix: Vec<Suffix>,
    pub position: std::ops::Range<usize>,
}
pub type PrefixOp = String;
pub type InfixOp = String;
#[allow(non_camel_case_types)]
#[derive(Debug, Clone)]
pub enum Suffix {
    DotCall(DotCall),
    SuffixOp(SuffixOp),
}
pub type SuffixOp = String;
#[derive(Debug, Clone)]
pub struct DotCall {
    pub call: IdentifierNode,
}
#[derive(Debug, Clone)]
pub struct FunctionArgs {
    pub args: Vec<ExpressionNode>,
}
#[allow(non_camel_case_types)]
#[derive(Debug, Clone)]
pub enum ValueNode {
    BooleanNode(BooleanNode),
    DecimalNode(DecimalNode),
    IntegerNode(IntegerNode),
    NamespaceNode(NamespaceNode),
    StringNode(StringNode),
}
#[derive(Debug, Clone)]
pub struct SlotL {
    pub trim: Option<TrimMode>,
    pub position: std::ops::Range<usize>,
}
#[derive(Debug, Clone)]
pub struct SlotR {
    pub trim: Option<TrimMode>,
    pub position: std::ops::Range<usize>,
}
pub type TrimMode = char;
#[derive(Debug, Clone)]
pub struct NamespaceNode {
    pub path: Vec<IdentifierNode>,
    pub position: std::ops::Range<usize>,
}
#[derive(Debug, Clone)]
pub struct IdentifierNode {
    pub string: String,
    pub position: std::ops::Range<usize>,
}
pub type XID_START = char;
pub type XID_CONTINUE = char;
#[derive(Debug, Clone)]
pub struct BooleanNode {
    pub string: String,
    pub position: std::ops::Range<usize>,
}
#[derive(Debug, Clone)]
pub struct IntegerNode {
    pub string: String,
    pub position: std::ops::Range<usize>,
}
#[derive(Debug, Clone)]
pub struct DecimalNode {
    pub string: String,
    pub position: std::ops::Range<usize>,
}
#[derive(Debug, Clone)]
pub struct UnicodeText {
    pub string: String,
    pub position: std::ops::Range<usize>,
}
#[derive(Debug, Clone)]
pub struct StringNode {
    pub dq: Option<DQ>,
    pub body: Vec<StringItem>,
    pub sq: Option<SQ>,
    pub position: std::ops::Range<usize>,
}
#[allow(non_camel_case_types)]
#[derive(Debug, Clone)]
pub enum StringItem {
    EscapeOther(EscapeOther),
    EscapeUnicode(EscapeUnicode),
    char(char),
}
#[derive(Debug, Clone)]
pub struct SQ;
#[derive(Debug, Clone)]
pub struct DQ;
pub type EscapeOther = char;
#[derive(Debug, Clone)]
pub struct EscapeUnicode;
#[derive(Debug, Clone)]
pub struct Comment {
    pub left: CommentL,
    pub right: CommentR,
}
#[derive(Debug, Clone)]
pub struct CommentL {
    pub trim: Option<TrimMode>,
    pub position: std::ops::Range<usize>,
}
#[derive(Debug, Clone)]
pub struct CommentR {
    pub trim: Option<TrimMode>,
    pub position: std::ops::Range<usize>,
}
impl peginator_generated::PegParserAdvanced<()> for SahaParser {
    fn parse_advanced<TT: peginator_generated::ParseTracer>(
        s: &str,
        settings: &peginator_generated::ParseSettings,
        user_defined: (),
    ) -> Result<Self, peginator_generated::ParseError> {
        Ok(peginator_generated::parse_SahaParser(
            peginator_generated::ParseState::new(s, settings),
            &mut peginator_generated::ParseGlobal::<TT, peginator_generated::ParseCache, ()>::new(
                Default::default(),
                user_defined,
            ),
        )?
        .result)
    }
}
#[allow(non_snake_case, unused_variables, unused_imports, unused_mut, dead_code)]
mod peginator_generated {
    use super::*;
    use peginator::*;
    pub use peginator::{
        IndentedTracer, ParseError, ParseGlobal, ParseSettings, ParseState, ParseTracer, PegParser, PegParserAdvanced,
        PegPosition,
    };
    #[derive(Default)]
    pub struct ParseCache<'a> {
        _please_dont_complain: std::marker::PhantomData<&'a ()>,
    }
    mod SahaParser_impl {
        use super::*;
        #[inline(always)]
        pub fn parse<'a, TT: ParseTracer>(
            state: ParseState<'a>,
            global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
        ) -> ParseResult<'a, Parsed> {
            let ParseOk { result: parsed, state } = parse_Whitespace(state, &mut *global)
                .and_then(|ParseOk { state, .. }| parse_SahaStatementNodes(state, &mut *global))?;
            let ParseOk { state, .. } =
                parse_Whitespace(state, &mut *global).and_then(|ParseOk { state, .. }| parse_end_of_input(state))?;
            Ok(ParseOk { result: parsed, state })
        }
        pub type Parsed = SahaStatementNodes;
    }
    #[inline]
    pub(super) fn parse_SahaParser<'a, TT: ParseTracer>(
        state: ParseState<'a>,
        global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
    ) -> ParseResult<'a, SahaParser> {
        global.tracer.print_trace_start(&state, "SahaParser");
        let result = {
            let result = SahaParser_impl::parse(state, global)?.map(|r| super::SahaParser { parsed: r });
            Ok(result)
        };
        global.tracer.print_trace_result(&result);
        result
    }
    mod SahaStatementNodes_impl {
        use super::*;
        mod closure {
            use super::*;
        }
        #[inline(always)]
        pub fn parse<'a, TT: ParseTracer>(
            state: ParseState<'a>,
            global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
        ) -> ParseResult<'a, Parsed> {
            let mut iterations: usize = 0;
            let mut state = state;
            let mut statements: Vec<SahaStatement> = Vec::new();
            loop {
                match parse_SahaStatement(state.clone(), &mut *global).map_inner(|result| vec![result]) {
                    Ok(ParseOk { result: __result, state: new_state, .. }) => {
                        statements.extend(__result);
                        state = new_state;
                    }
                    Err(err) => {
                        state = state.record_error(err);
                        break;
                    }
                }
                iterations += 1;
            }
            Ok(ParseOk { result: statements, state })
        }
        pub type Parsed = Vec<SahaStatement>;
    }
    #[inline]
    pub(super) fn parse_SahaStatementNodes<'a, TT: ParseTracer>(
        state: ParseState<'a>,
        global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
    ) -> ParseResult<'a, SahaStatementNodes> {
        global.tracer.print_trace_start(&state, "SahaStatementNodes");
        let result = {
            let result = SahaStatementNodes_impl::parse(state, global)?.map(|r| super::SahaStatementNodes { statements: r });
            Ok(result)
        };
        global.tracer.print_trace_result(&result);
        result
    }
    mod SahaStatement_impl {
        use super::*;
        #[inline(always)]
        pub fn parse<'a, TT: ParseTracer>(
            state: ParseState<'a>,
            global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
        ) -> ParseResult<'a, Parsed> {
            ChoiceHelper::new(state)
                .choice(|state| {
                    parse_Whitespace(state, &mut *global)
                        .and_then(|ParseOk { state, .. }| parse_SlotFor(state, global))
                        .map_inner(Parsed__override::SlotFor)
                })
                .choice(|state| {
                    parse_Whitespace(state, &mut *global)
                        .and_then(|ParseOk { state, .. }| parse_SlotIf(state, global))
                        .map_inner(Parsed__override::SlotIf)
                })
                .choice(|state| {
                    parse_Whitespace(state, &mut *global)
                        .and_then(|ParseOk { state, .. }| parse_SlotExpressionNode(state, global))
                        .map_inner(Parsed__override::SlotExpressionNode)
                })
                .choice(|state| {
                    parse_Whitespace(state, &mut *global)
                        .and_then(|ParseOk { state, .. }| parse_UnicodeText(state, global))
                        .map_inner(Parsed__override::UnicodeText)
                })
                .end()
        }
        pub type Parsed = Parsed__override;
        use super::SahaStatement as Parsed__override;
    }
    #[inline]
    pub(super) fn parse_SahaStatement<'a, TT: ParseTracer>(
        state: ParseState<'a>,
        global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
    ) -> ParseResult<'a, SahaStatement> {
        global.tracer.print_trace_start(&state, "SahaStatement");
        let result = {
            let result = SahaStatement_impl::parse(state, global)?;
            Ok(result)
        };
        global.tracer.print_trace_result(&result);
        result
    }
    mod SlotIf_impl {
        use super::*;
        mod part_2 {
            use super::*;
            mod closure {
                use super::*;
            }
            #[inline(always)]
            pub fn parse<'a, TT: ParseTracer>(
                state: ParseState<'a>,
                global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
            ) -> ParseResult<'a, Parsed> {
                let mut iterations: usize = 0;
                let mut state = state;
                let mut else_if: Vec<SlotElseIf> = Vec::new();
                loop {
                    match parse_SlotElseIf(state.clone(), &mut *global).map_inner(|result| vec![result]) {
                        Ok(ParseOk { result: __result, state: new_state, .. }) => {
                            else_if.extend(__result);
                            state = new_state;
                        }
                        Err(err) => {
                            state = state.record_error(err);
                            break;
                        }
                    }
                    iterations += 1;
                }
                Ok(ParseOk { result: else_if, state })
            }
            pub type Parsed = Vec<SlotElseIf>;
        }
        #[inline(always)]
        pub fn parse<'a, TT: ParseTracer>(
            state: ParseState<'a>,
            global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
        ) -> ParseResult<'a, Parsed> {
            let ParseOk { result: start, state } = parse_SlotIfStart(state, &mut *global)?;
            let ParseOk { result: body, state } = parse_SahaStatementNodes(state, &mut *global)?;
            let ParseOk { result: mut else_if, state } = part_2::parse(state, global)?;
            let ParseOk { result: r#else, state } = parse_SlotElse(state.clone(), &mut *global)
                .map_inner(Some)
                .or_else(|err| Ok(ParseOk { result: Default::default(), state: state.record_error(err) }))?;
            let ParseOk { result: end, state } = parse_SlotEndIf(state, &mut *global)?;
            Ok(ParseOk { result: Parsed { start, body, else_if, r#else, end }, state })
        }
        pub struct Parsed {
            pub start: SlotIfStart,
            pub body: SahaStatementNodes,
            pub else_if: Vec<SlotElseIf>,
            pub r#else: Option<SlotElse>,
            pub end: SlotEndIf,
        }
    }
    #[inline]
    pub(super) fn parse_SlotIf<'a, TT: ParseTracer>(
        state: ParseState<'a>,
        global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
    ) -> ParseResult<'a, SlotIf> {
        global.tracer.print_trace_start(&state, "SlotIf");
        let result = {
            let result = SlotIf_impl::parse(state.clone(), global)?.map_with_state(|r, new_state| super::SlotIf {
                start: r.start,
                body: r.body,
                else_if: r.else_if,
                r#else: r.r#else,
                end: r.end,
                position: state.range_until(new_state),
            });
            Ok(result)
        };
        global.tracer.print_trace_result(&result);
        result
    }
    impl PegPosition for SlotIf {
        fn position(&self) -> &std::ops::Range<usize> {
            &self.position
        }
    }
    mod SlotIfStart_impl {
        use super::*;
        #[inline(always)]
        pub fn parse<'a, TT: ParseTracer>(
            state: ParseState<'a>,
            global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
        ) -> ParseResult<'a, Parsed> {
            let ParseOk { result: left, state } =
                parse_Whitespace(state, &mut *global).and_then(|ParseOk { state, .. }| parse_SlotL(state, &mut *global))?;
            let ParseOk { state, .. } = parse_Whitespace(state, &mut *global)
                .and_then(|ParseOk { state, .. }| parse_string_literal(state, "if"))
                .discard_result()?;
            let ParseOk { result: cond, state } = parse_Whitespace(state, &mut *global)
                .and_then(|ParseOk { state, .. }| parse_ExpressionNode(state, &mut *global))?;
            let ParseOk { result: right, state } =
                parse_Whitespace(state, &mut *global).and_then(|ParseOk { state, .. }| parse_SlotR(state, &mut *global))?;
            Ok(ParseOk { result: Parsed { left, cond, right }, state })
        }
        pub struct Parsed {
            pub left: SlotL,
            pub cond: ExpressionNode,
            pub right: SlotR,
        }
    }
    #[inline]
    pub(super) fn parse_SlotIfStart<'a, TT: ParseTracer>(
        state: ParseState<'a>,
        global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
    ) -> ParseResult<'a, SlotIfStart> {
        global.tracer.print_trace_start(&state, "SlotIfStart");
        let result = {
            let result = SlotIfStart_impl::parse(state, global)?.map(|r| super::SlotIfStart {
                left: r.left,
                cond: r.cond,
                right: r.right,
            });
            Ok(result)
        };
        global.tracer.print_trace_result(&result);
        result
    }
    mod SlotElseIf_impl {
        use super::*;
        mod part_1 {
            use super::*;
            mod choice_0 {
                use super::*;
                #[inline(always)]
                pub fn parse<'a, TT: ParseTracer>(
                    state: ParseState<'a>,
                    global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
                ) -> ParseResult<'a, Parsed> {
                    let ParseOk { state, .. } = parse_Whitespace(state, &mut *global)
                        .and_then(|ParseOk { state, .. }| parse_string_literal(state, "else"))
                        .discard_result()?;
                    let ParseOk { state, .. } = parse_Whitespace(state, &mut *global)
                        .and_then(|ParseOk { state, .. }| parse_string_literal(state, "if"))
                        .discard_result()?;
                    Ok(ParseOk { result: (), state })
                }
                pub type Parsed = ();
            }
            #[inline(always)]
            pub fn parse<'a, TT: ParseTracer>(
                state: ParseState<'a>,
                global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
            ) -> ParseResult<'a, Parsed> {
                ChoiceHelper::new(state)
                    .choice(|state| choice_0::parse(state, global))
                    .choice(|state| {
                        parse_Whitespace(state, &mut *global)
                            .and_then(|ParseOk { state, .. }| parse_string_literal(state, "else-if"))
                            .discard_result()
                    })
                    .end()
            }
            pub type Parsed = ();
        }
        #[inline(always)]
        pub fn parse<'a, TT: ParseTracer>(
            state: ParseState<'a>,
            global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
        ) -> ParseResult<'a, Parsed> {
            let ParseOk { result: left, state } =
                parse_Whitespace(state, &mut *global).and_then(|ParseOk { state, .. }| parse_SlotL(state, &mut *global))?;
            let ParseOk { state, .. } = part_1::parse(state, global)?;
            let ParseOk { result: cond, state } = parse_Whitespace(state, &mut *global)
                .and_then(|ParseOk { state, .. }| parse_ExpressionNode(state, &mut *global))?;
            let ParseOk { result: right, state } =
                parse_Whitespace(state, &mut *global).and_then(|ParseOk { state, .. }| parse_SlotR(state, &mut *global))?;
            let ParseOk { result: body, state } = parse_Whitespace(state, &mut *global)
                .and_then(|ParseOk { state, .. }| parse_SahaStatementNodes(state, &mut *global))?;
            Ok(ParseOk { result: Parsed { left, cond, right, body }, state })
        }
        pub struct Parsed {
            pub left: SlotL,
            pub cond: ExpressionNode,
            pub right: SlotR,
            pub body: SahaStatementNodes,
        }
    }
    #[inline]
    pub(super) fn parse_SlotElseIf<'a, TT: ParseTracer>(
        state: ParseState<'a>,
        global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
    ) -> ParseResult<'a, SlotElseIf> {
        global.tracer.print_trace_start(&state, "SlotElseIf");
        let result = {
            let result = SlotElseIf_impl::parse(state, global)?.map(|r| super::SlotElseIf {
                left: r.left,
                cond: r.cond,
                right: r.right,
                body: r.body,
            });
            Ok(result)
        };
        global.tracer.print_trace_result(&result);
        result
    }
    mod SlotElse_impl {
        use super::*;
        #[inline(always)]
        pub fn parse<'a, TT: ParseTracer>(
            state: ParseState<'a>,
            global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
        ) -> ParseResult<'a, Parsed> {
            let ParseOk { result: left, state } =
                parse_Whitespace(state, &mut *global).and_then(|ParseOk { state, .. }| parse_SlotL(state, &mut *global))?;
            let ParseOk { state, .. } = parse_Whitespace(state, &mut *global)
                .and_then(|ParseOk { state, .. }| parse_string_literal(state, "else"))
                .discard_result()?;
            let ParseOk { result: right, state } =
                parse_Whitespace(state, &mut *global).and_then(|ParseOk { state, .. }| parse_SlotR(state, &mut *global))?;
            let ParseOk { result: body, state } = parse_Whitespace(state, &mut *global)
                .and_then(|ParseOk { state, .. }| parse_SahaStatementNodes(state, &mut *global))?;
            Ok(ParseOk { result: Parsed { left, right, body }, state })
        }
        pub struct Parsed {
            pub left: SlotL,
            pub right: SlotR,
            pub body: SahaStatementNodes,
        }
    }
    #[inline]
    pub(super) fn parse_SlotElse<'a, TT: ParseTracer>(
        state: ParseState<'a>,
        global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
    ) -> ParseResult<'a, SlotElse> {
        global.tracer.print_trace_start(&state, "SlotElse");
        let result = {
            let result =
                SlotElse_impl::parse(state, global)?.map(|r| super::SlotElse { left: r.left, right: r.right, body: r.body });
            Ok(result)
        };
        global.tracer.print_trace_result(&result);
        result
    }
    mod SlotEndIf_impl {
        use super::*;
        #[inline(always)]
        pub fn parse<'a, TT: ParseTracer>(
            state: ParseState<'a>,
            global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
        ) -> ParseResult<'a, Parsed> {
            let ParseOk { result: left, state } =
                parse_Whitespace(state, &mut *global).and_then(|ParseOk { state, .. }| parse_SlotL(state, &mut *global))?;
            let ParseOk { state, .. } = parse_Whitespace(state, &mut *global)
                .and_then(|ParseOk { state, .. }| parse_EndIf(state, &mut *global))
                .discard_result()?;
            let ParseOk { result: right, state } =
                parse_Whitespace(state, &mut *global).and_then(|ParseOk { state, .. }| parse_SlotR(state, &mut *global))?;
            Ok(ParseOk { result: Parsed { left, right }, state })
        }
        pub struct Parsed {
            pub left: SlotL,
            pub right: SlotR,
        }
    }
    #[inline]
    pub(super) fn parse_SlotEndIf<'a, TT: ParseTracer>(
        state: ParseState<'a>,
        global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
    ) -> ParseResult<'a, SlotEndIf> {
        global.tracer.print_trace_start(&state, "SlotEndIf");
        let result = {
            let result = SlotEndIf_impl::parse(state, global)?.map(|r| super::SlotEndIf { left: r.left, right: r.right });
            Ok(result)
        };
        global.tracer.print_trace_result(&result);
        result
    }
    mod EndIf_impl {
        use super::*;
        #[inline(always)]
        pub fn parse<'a, TT: ParseTracer>(
            state: ParseState<'a>,
            global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
        ) -> ParseResult<'a, Parsed> {
            ChoiceHelper::new(state)
                .choice(|state| {
                    parse_Whitespace(state, &mut *global)
                        .and_then(|ParseOk { state, .. }| parse_string_literal(state, "end-if"))
                        .discard_result()
                })
                .choice(|state| {
                    parse_Whitespace(state, &mut *global)
                        .and_then(|ParseOk { state, .. }| parse_string_literal(state, "endif"))
                        .discard_result()
                })
                .choice(|state| {
                    parse_Whitespace(state, &mut *global)
                        .and_then(|ParseOk { state, .. }| parse_string_literal(state, "end"))
                        .discard_result()
                })
                .end()
        }
        pub type Parsed = ();
    }
    #[inline]
    pub(super) fn parse_EndIf<'a, TT: ParseTracer>(
        state: ParseState<'a>,
        global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
    ) -> ParseResult<'a, EndIf> {
        global.tracer.print_trace_start(&state, "EndIf");
        let result = {
            let result = EndIf_impl::parse(state, global)?.map(|r| super::EndIf {});
            Ok(result)
        };
        global.tracer.print_trace_result(&result);
        result
    }
    mod SlotFor_impl {
        use super::*;
        #[inline(always)]
        pub fn parse<'a, TT: ParseTracer>(
            state: ParseState<'a>,
            global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
        ) -> ParseResult<'a, Parsed> {
            let ParseOk { result: start, state } = parse_SlotForStart(state, &mut *global)?;
            let ParseOk { result: body, state } = parse_SahaStatementNodes(state, &mut *global)?;
            let ParseOk { result: r#else, state } = parse_SlotElse(state.clone(), &mut *global)
                .map_inner(Some)
                .or_else(|err| Ok(ParseOk { result: Default::default(), state: state.record_error(err) }))?;
            let ParseOk { result: end, state } = parse_SlotEndFor(state, &mut *global)?;
            Ok(ParseOk { result: Parsed { start, body, r#else, end }, state })
        }
        pub struct Parsed {
            pub start: SlotForStart,
            pub body: SahaStatementNodes,
            pub r#else: Option<SlotElse>,
            pub end: SlotEndFor,
        }
    }
    #[inline]
    pub(super) fn parse_SlotFor<'a, TT: ParseTracer>(
        state: ParseState<'a>,
        global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
    ) -> ParseResult<'a, SlotFor> {
        global.tracer.print_trace_start(&state, "SlotFor");
        let result = {
            let result = SlotFor_impl::parse(state.clone(), global)?.map_with_state(|r, new_state| super::SlotFor {
                start: r.start,
                body: r.body,
                r#else: r.r#else,
                end: r.end,
                position: state.range_until(new_state),
            });
            Ok(result)
        };
        global.tracer.print_trace_result(&result);
        result
    }
    impl PegPosition for SlotFor {
        fn position(&self) -> &std::ops::Range<usize> {
            &self.position
        }
    }
    mod SlotForStart_impl {
        use super::*;
        #[inline(always)]
        pub fn parse<'a, TT: ParseTracer>(
            state: ParseState<'a>,
            global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
        ) -> ParseResult<'a, Parsed> {
            let ParseOk { result: left, state } =
                parse_Whitespace(state, &mut *global).and_then(|ParseOk { state, .. }| parse_SlotL(state, &mut *global))?;
            let ParseOk { state, .. } = parse_Whitespace(state, &mut *global)
                .and_then(|ParseOk { state, .. }| parse_string_literal(state, "for"))
                .discard_result()?;
            let ParseOk { result: pattern, state } =
                parse_Whitespace(state, &mut *global).and_then(|ParseOk { state, .. }| parse_ValueNode(state, &mut *global))?;
            let ParseOk { state, .. } = parse_Whitespace(state, &mut *global)
                .and_then(|ParseOk { state, .. }| parse_string_literal(state, "in"))
                .discard_result()?;
            let ParseOk { result: expression, state } = parse_Whitespace(state, &mut *global)
                .and_then(|ParseOk { state, .. }| parse_ExpressionNode(state, &mut *global))?;
            let ParseOk { result: right, state } =
                parse_Whitespace(state, &mut *global).and_then(|ParseOk { state, .. }| parse_SlotR(state, &mut *global))?;
            Ok(ParseOk { result: Parsed { left, pattern, expression, right }, state })
        }
        pub struct Parsed {
            pub left: SlotL,
            pub pattern: ValueNode,
            pub expression: ExpressionNode,
            pub right: SlotR,
        }
    }
    #[inline]
    pub(super) fn parse_SlotForStart<'a, TT: ParseTracer>(
        state: ParseState<'a>,
        global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
    ) -> ParseResult<'a, SlotForStart> {
        global.tracer.print_trace_start(&state, "SlotForStart");
        let result = {
            let result = SlotForStart_impl::parse(state, global)?.map(|r| super::SlotForStart {
                left: r.left,
                pattern: r.pattern,
                expression: r.expression,
                right: r.right,
            });
            Ok(result)
        };
        global.tracer.print_trace_result(&result);
        result
    }
    mod SlotEndFor_impl {
        use super::*;
        #[inline(always)]
        pub fn parse<'a, TT: ParseTracer>(
            state: ParseState<'a>,
            global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
        ) -> ParseResult<'a, Parsed> {
            let ParseOk { result: left, state } =
                parse_Whitespace(state, &mut *global).and_then(|ParseOk { state, .. }| parse_SlotL(state, &mut *global))?;
            let ParseOk { state, .. } = parse_Whitespace(state, &mut *global)
                .and_then(|ParseOk { state, .. }| parse_EndFor(state, &mut *global))
                .discard_result()?;
            let ParseOk { result: right, state } =
                parse_Whitespace(state, &mut *global).and_then(|ParseOk { state, .. }| parse_SlotR(state, &mut *global))?;
            Ok(ParseOk { result: Parsed { left, right }, state })
        }
        pub struct Parsed {
            pub left: SlotL,
            pub right: SlotR,
        }
    }
    #[inline]
    pub(super) fn parse_SlotEndFor<'a, TT: ParseTracer>(
        state: ParseState<'a>,
        global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
    ) -> ParseResult<'a, SlotEndFor> {
        global.tracer.print_trace_start(&state, "SlotEndFor");
        let result = {
            let result = SlotEndFor_impl::parse(state, global)?.map(|r| super::SlotEndFor { left: r.left, right: r.right });
            Ok(result)
        };
        global.tracer.print_trace_result(&result);
        result
    }
    mod EndFor_impl {
        use super::*;
        mod part_1 {
            use super::*;
            mod optional {
                use super::*;
                #[inline(always)]
                pub fn parse<'a, TT: ParseTracer>(
                    state: ParseState<'a>,
                    global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
                ) -> ParseResult<'a, Parsed> {
                    let ParseOk { state, .. } = parse_character_literal(state, '-').discard_result()?;
                    let ParseOk { state, .. } = parse_string_literal(state, "for").discard_result()?;
                    Ok(ParseOk { result: (), state })
                }
                pub type Parsed = ();
            }
            #[inline(always)]
            pub fn parse<'a, TT: ParseTracer>(
                state: ParseState<'a>,
                global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
            ) -> ParseResult<'a, Parsed> {
                optional::parse(state.clone(), global).or_else(|err| Ok(ParseOk { result: (), state: state.record_error(err) }))
            }
            pub type Parsed = ();
        }
        #[inline(always)]
        pub fn parse<'a, TT: ParseTracer>(
            state: ParseState<'a>,
            global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
        ) -> ParseResult<'a, Parsed> {
            let ParseOk { state, .. } = parse_string_literal(state, "end").discard_result()?;
            let ParseOk { state, .. } = part_1::parse(state, global)?;
            Ok(ParseOk { result: (), state })
        }
        pub type Parsed = ();
    }
    #[inline]
    pub(super) fn parse_EndFor<'a, TT: ParseTracer>(
        state: ParseState<'a>,
        global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
    ) -> ParseResult<'a, EndFor> {
        global.tracer.print_trace_start(&state, "EndFor");
        let result = {
            let result = EndFor_impl::parse(state, global)?.map(|r| super::EndFor {});
            Ok(result)
        };
        global.tracer.print_trace_result(&result);
        result
    }
    mod SlotExpressionNode_impl {
        use super::*;
        #[inline(always)]
        pub fn parse<'a, TT: ParseTracer>(
            state: ParseState<'a>,
            global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
        ) -> ParseResult<'a, Parsed> {
            let ParseOk { result: left, state } =
                parse_Whitespace(state, &mut *global).and_then(|ParseOk { state, .. }| parse_SlotL(state, &mut *global))?;
            let ParseOk { result: e, state } = parse_Whitespace(state, &mut *global)
                .and_then(|ParseOk { state, .. }| parse_ExpressionNode(state, &mut *global))?;
            let ParseOk { result: right, state } =
                parse_Whitespace(state, &mut *global).and_then(|ParseOk { state, .. }| parse_SlotR(state, &mut *global))?;
            Ok(ParseOk { result: Parsed { left, e, right }, state })
        }
        pub struct Parsed {
            pub left: SlotL,
            pub e: ExpressionNode,
            pub right: SlotR,
        }
    }
    #[inline]
    pub(super) fn parse_SlotExpressionNode<'a, TT: ParseTracer>(
        state: ParseState<'a>,
        global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
    ) -> ParseResult<'a, SlotExpressionNode> {
        global.tracer.print_trace_start(&state, "SlotExpressionNode");
        let result = {
            let result = SlotExpressionNode_impl::parse(state, global)?.map(|r| super::SlotExpressionNode {
                left: r.left,
                e: r.e,
                right: r.right,
            });
            if !crate::utils::check_slot_expression(&result.result) {
                return Err(result.state.report_error(ParseErrorSpecifics::CheckFunctionFailed {
                    function_name: "crate::utils::check_slot_expression",
                }));
            }
            Ok(result)
        };
        global.tracer.print_trace_result(&result);
        result
    }
    mod ExpressionNode_impl {
        use super::*;
        mod part_1 {
            use super::*;
            mod closure {
                use super::*;
            }
            #[inline(always)]
            pub fn parse<'a, TT: ParseTracer>(
                state: ParseState<'a>,
                global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
            ) -> ParseResult<'a, Parsed> {
                let mut iterations: usize = 0;
                let mut state = state;
                let mut infix: Vec<ExpressionNodeInfix> = Vec::new();
                loop {
                    match parse_Whitespace(state.clone(), &mut *global)
                        .and_then(|ParseOk { state, .. }| parse_ExpressionNodeInfix(state, &mut *global))
                        .map_inner(|result| vec![result])
                    {
                        Ok(ParseOk { result: __result, state: new_state, .. }) => {
                            infix.extend(__result);
                            state = new_state;
                        }
                        Err(err) => {
                            state = state.record_error(err);
                            break;
                        }
                    }
                    iterations += 1;
                }
                Ok(ParseOk { result: infix, state })
            }
            pub type Parsed = Vec<ExpressionNodeInfix>;
        }
        #[inline(always)]
        pub fn parse<'a, TT: ParseTracer>(
            state: ParseState<'a>,
            global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
        ) -> ParseResult<'a, Parsed> {
            let ParseOk { result: head, state } =
                parse_Whitespace(state, &mut *global).and_then(|ParseOk { state, .. }| parse_TermNode(state, &mut *global))?;
            let ParseOk { result: mut infix, state } = part_1::parse(state, global)?;
            Ok(ParseOk { result: Parsed { head, infix }, state })
        }
        pub struct Parsed {
            pub head: TermNode,
            pub infix: Vec<ExpressionNodeInfix>,
        }
    }
    #[inline]
    pub(super) fn parse_ExpressionNode<'a, TT: ParseTracer>(
        state: ParseState<'a>,
        global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
    ) -> ParseResult<'a, ExpressionNode> {
        global.tracer.print_trace_start(&state, "ExpressionNode");
        let result = {
            let result = ExpressionNode_impl::parse(state.clone(), global)?.map_with_state(|r, new_state| {
                super::ExpressionNode { head: r.head, infix: r.infix, position: state.range_until(new_state) }
            });
            Ok(result)
        };
        global.tracer.print_trace_result(&result);
        result
    }
    impl PegPosition for ExpressionNode {
        fn position(&self) -> &std::ops::Range<usize> {
            &self.position
        }
    }
    mod ExpressionNodeInfix_impl {
        use super::*;
        #[inline(always)]
        pub fn parse<'a, TT: ParseTracer>(
            state: ParseState<'a>,
            global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
        ) -> ParseResult<'a, Parsed> {
            let ParseOk { result: op, state } =
                parse_Whitespace(state, &mut *global).and_then(|ParseOk { state, .. }| parse_InfixOp(state, &mut *global))?;
            let ParseOk { result: value, state } =
                parse_Whitespace(state, &mut *global).and_then(|ParseOk { state, .. }| parse_TermNode(state, &mut *global))?;
            Ok(ParseOk { result: Parsed { op, value }, state })
        }
        pub struct Parsed {
            pub op: InfixOp,
            pub value: TermNode,
        }
    }
    #[inline]
    pub(super) fn parse_ExpressionNodeInfix<'a, TT: ParseTracer>(
        state: ParseState<'a>,
        global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
    ) -> ParseResult<'a, ExpressionNodeInfix> {
        global.tracer.print_trace_start(&state, "ExpressionNodeInfix");
        let result = {
            let result = ExpressionNodeInfix_impl::parse(state, global)?
                .map(|r| super::ExpressionNodeInfix { op: r.op, value: r.value });
            Ok(result)
        };
        global.tracer.print_trace_result(&result);
        result
    }
    mod TermNode_impl {
        use super::*;
        mod part_0 {
            use super::*;
            mod closure {
                use super::*;
            }
            #[inline(always)]
            pub fn parse<'a, TT: ParseTracer>(
                state: ParseState<'a>,
                global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
            ) -> ParseResult<'a, Parsed> {
                let mut iterations: usize = 0;
                let mut state = state;
                let mut prefix: Vec<PrefixOp> = Vec::new();
                loop {
                    match parse_Whitespace(state.clone(), &mut *global)
                        .and_then(|ParseOk { state, .. }| parse_PrefixOp(state, &mut *global))
                        .map_inner(|result| vec![result])
                    {
                        Ok(ParseOk { result: __result, state: new_state, .. }) => {
                            prefix.extend(__result);
                            state = new_state;
                        }
                        Err(err) => {
                            state = state.record_error(err);
                            break;
                        }
                    }
                    iterations += 1;
                }
                Ok(ParseOk { result: prefix, state })
            }
            pub type Parsed = Vec<PrefixOp>;
        }
        mod part_2 {
            use super::*;
            mod closure {
                use super::*;
            }
            #[inline(always)]
            pub fn parse<'a, TT: ParseTracer>(
                state: ParseState<'a>,
                global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
            ) -> ParseResult<'a, Parsed> {
                let mut iterations: usize = 0;
                let mut state = state;
                let mut suffix: Vec<Suffix> = Vec::new();
                loop {
                    match parse_Whitespace(state.clone(), &mut *global)
                        .and_then(|ParseOk { state, .. }| parse_Suffix(state, &mut *global))
                        .map_inner(|result| vec![result])
                    {
                        Ok(ParseOk { result: __result, state: new_state, .. }) => {
                            suffix.extend(__result);
                            state = new_state;
                        }
                        Err(err) => {
                            state = state.record_error(err);
                            break;
                        }
                    }
                    iterations += 1;
                }
                Ok(ParseOk { result: suffix, state })
            }
            pub type Parsed = Vec<Suffix>;
        }
        #[inline(always)]
        pub fn parse<'a, TT: ParseTracer>(
            state: ParseState<'a>,
            global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
        ) -> ParseResult<'a, Parsed> {
            let ParseOk { result: mut prefix, state } = part_0::parse(state, global)?;
            let ParseOk { result: term, state } =
                parse_Whitespace(state, &mut *global).and_then(|ParseOk { state, .. }| parse_ValueNode(state, &mut *global))?;
            let ParseOk { result: mut suffix, state } = part_2::parse(state, global)?;
            Ok(ParseOk { result: Parsed { prefix, term, suffix }, state })
        }
        pub struct Parsed {
            pub prefix: Vec<PrefixOp>,
            pub term: ValueNode,
            pub suffix: Vec<Suffix>,
        }
    }
    #[inline]
    pub(super) fn parse_TermNode<'a, TT: ParseTracer>(
        state: ParseState<'a>,
        global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
    ) -> ParseResult<'a, TermNode> {
        global.tracer.print_trace_start(&state, "TermNode");
        let result = {
            let result = TermNode_impl::parse(state.clone(), global)?.map_with_state(|r, new_state| super::TermNode {
                prefix: r.prefix,
                term: r.term,
                suffix: r.suffix,
                position: state.range_until(new_state),
            });
            Ok(result)
        };
        global.tracer.print_trace_result(&result);
        result
    }
    impl PegPosition for TermNode {
        fn position(&self) -> &std::ops::Range<usize> {
            &self.position
        }
    }
    mod PrefixOp_impl {
        use super::*;
        #[inline(always)]
        pub fn parse<'a, TT: ParseTracer>(
            state: ParseState<'a>,
            global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
        ) -> ParseResult<'a, Parsed> {
            ChoiceHelper::new(state)
                .choice(|state| {
                    parse_Whitespace(state, &mut *global)
                        .and_then(|ParseOk { state, .. }| parse_character_literal(state, '&'))
                        .discard_result()
                })
                .choice(|state| {
                    parse_Whitespace(state, &mut *global)
                        .and_then(|ParseOk { state, .. }| parse_character_literal(state, '+'))
                        .discard_result()
                })
                .choice(|state| {
                    parse_Whitespace(state, &mut *global)
                        .and_then(|ParseOk { state, .. }| parse_character_literal(state, '-'))
                        .discard_result()
                })
                .choice(|state| {
                    parse_Whitespace(state, &mut *global)
                        .and_then(|ParseOk { state, .. }| parse_character_literal(state, '*'))
                        .discard_result()
                })
                .end()
        }
        pub type Parsed = ();
    }
    #[inline]
    pub(super) fn parse_PrefixOp<'a, TT: ParseTracer>(
        state: ParseState<'a>,
        global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
    ) -> ParseResult<'a, PrefixOp> {
        global.tracer.print_trace_start(&state, "PrefixOp");
        let result = {
            let result = PrefixOp_impl::parse(state.clone(), global)?.map_with_state(|_, new_state| {
                let string = state.slice_until(new_state).to_string();
                string
            });
            Ok(result)
        };
        global.tracer.print_trace_result(&result);
        result
    }
    mod InfixOp_impl {
        use super::*;
        #[inline(always)]
        pub fn parse<'a, TT: ParseTracer>(
            state: ParseState<'a>,
            global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
        ) -> ParseResult<'a, Parsed> {
            ChoiceHelper::new(state)
                .choice(|state| {
                    parse_Whitespace(state, &mut *global)
                        .and_then(|ParseOk { state, .. }| parse_character_literal(state, '+'))
                        .discard_result()
                })
                .choice(|state| {
                    parse_Whitespace(state, &mut *global)
                        .and_then(|ParseOk { state, .. }| parse_character_literal(state, '-'))
                        .discard_result()
                })
                .choice(|state| {
                    parse_Whitespace(state, &mut *global)
                        .and_then(|ParseOk { state, .. }| parse_string_literal(state, "=="))
                        .discard_result()
                })
                .choice(|state| {
                    parse_Whitespace(state, &mut *global)
                        .and_then(|ParseOk { state, .. }| parse_string_literal(state, "<="))
                        .discard_result()
                })
                .choice(|state| {
                    parse_Whitespace(state, &mut *global)
                        .and_then(|ParseOk { state, .. }| parse_character_literal(state, '<'))
                        .discard_result()
                })
                .choice(|state| {
                    parse_Whitespace(state, &mut *global)
                        .and_then(|ParseOk { state, .. }| parse_string_literal(state, ">="))
                        .discard_result()
                })
                .choice(|state| {
                    parse_Whitespace(state, &mut *global)
                        .and_then(|ParseOk { state, .. }| parse_character_literal(state, '>'))
                        .discard_result()
                })
                .end()
        }
        pub type Parsed = ();
    }
    #[inline]
    pub(super) fn parse_InfixOp<'a, TT: ParseTracer>(
        state: ParseState<'a>,
        global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
    ) -> ParseResult<'a, InfixOp> {
        global.tracer.print_trace_start(&state, "InfixOp");
        let result = {
            let result = InfixOp_impl::parse(state.clone(), global)?.map_with_state(|_, new_state| {
                let string = state.slice_until(new_state).to_string();
                string
            });
            Ok(result)
        };
        global.tracer.print_trace_result(&result);
        result
    }
    mod Suffix_impl {
        use super::*;
        #[inline(always)]
        pub fn parse<'a, TT: ParseTracer>(
            state: ParseState<'a>,
            global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
        ) -> ParseResult<'a, Parsed> {
            ChoiceHelper::new(state)
                .choice(|state| {
                    parse_Whitespace(state, &mut *global)
                        .and_then(|ParseOk { state, .. }| parse_SuffixOp(state, global))
                        .map_inner(Parsed__override::SuffixOp)
                })
                .choice(|state| {
                    parse_Whitespace(state, &mut *global)
                        .and_then(|ParseOk { state, .. }| parse_DotCall(state, global))
                        .map_inner(Parsed__override::DotCall)
                })
                .end()
        }
        pub type Parsed = Parsed__override;
        use super::Suffix as Parsed__override;
    }
    #[inline]
    pub(super) fn parse_Suffix<'a, TT: ParseTracer>(
        state: ParseState<'a>,
        global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
    ) -> ParseResult<'a, Suffix> {
        global.tracer.print_trace_start(&state, "Suffix");
        let result = {
            let result = Suffix_impl::parse(state, global)?;
            Ok(result)
        };
        global.tracer.print_trace_result(&result);
        result
    }
    mod SuffixOp_impl {
        use super::*;
        #[inline(always)]
        pub fn parse<'a, TT: ParseTracer>(
            state: ParseState<'a>,
            global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
        ) -> ParseResult<'a, Parsed> {
            parse_Whitespace(state, &mut *global)
                .and_then(|ParseOk { state, .. }| parse_character_literal(state, '!'))
                .discard_result()
        }
        pub type Parsed = ();
    }
    #[inline]
    pub(super) fn parse_SuffixOp<'a, TT: ParseTracer>(
        state: ParseState<'a>,
        global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
    ) -> ParseResult<'a, SuffixOp> {
        global.tracer.print_trace_start(&state, "SuffixOp");
        let result = {
            let result = SuffixOp_impl::parse(state.clone(), global)?.map_with_state(|_, new_state| {
                let string = state.slice_until(new_state).to_string();
                string
            });
            Ok(result)
        };
        global.tracer.print_trace_result(&result);
        result
    }
    mod DotCall_impl {
        use super::*;
        #[inline(always)]
        pub fn parse<'a, TT: ParseTracer>(
            state: ParseState<'a>,
            global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
        ) -> ParseResult<'a, Parsed> {
            let ParseOk { state, .. } = parse_Whitespace(state, &mut *global)
                .and_then(|ParseOk { state, .. }| parse_character_literal(state, '.'))
                .discard_result()?;
            let ParseOk { result: call, state } = parse_Whitespace(state, &mut *global)
                .and_then(|ParseOk { state, .. }| parse_IdentifierNode(state, &mut *global))?;
            let ParseOk { state, .. } = parse_Whitespace(state.clone(), &mut *global)
                .and_then(|ParseOk { state, .. }| parse_FunctionArgs(state, &mut *global))
                .discard_result()
                .or_else(|err| Ok(ParseOk { result: (), state: state.record_error(err) }))?;
            Ok(ParseOk { result: call, state })
        }
        pub type Parsed = IdentifierNode;
    }
    #[inline]
    pub(super) fn parse_DotCall<'a, TT: ParseTracer>(
        state: ParseState<'a>,
        global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
    ) -> ParseResult<'a, DotCall> {
        global.tracer.print_trace_start(&state, "DotCall");
        let result = {
            let result = DotCall_impl::parse(state, global)?.map(|r| super::DotCall { call: r });
            Ok(result)
        };
        global.tracer.print_trace_result(&result);
        result
    }
    mod FunctionArgs_impl {
        use super::*;
        mod part_2 {
            use super::*;
            mod closure {
                use super::*;
                #[inline(always)]
                pub fn parse<'a, TT: ParseTracer>(
                    state: ParseState<'a>,
                    global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
                ) -> ParseResult<'a, Parsed> {
                    let ParseOk { state, .. } = parse_Whitespace(state.clone(), &mut *global)
                        .and_then(|ParseOk { state, .. }| parse_character_literal(state, ','))
                        .discard_result()
                        .or_else(|err| Ok(ParseOk { result: (), state: state.record_error(err) }))?;
                    let ParseOk { result: mut args, state } = parse_Whitespace(state, &mut *global)
                        .and_then(|ParseOk { state, .. }| parse_ExpressionNode(state, &mut *global))
                        .map_inner(|result| vec![result])?;
                    Ok(ParseOk { result: args, state })
                }
                pub type Parsed = Vec<ExpressionNode>;
            }
            #[inline(always)]
            pub fn parse<'a, TT: ParseTracer>(
                state: ParseState<'a>,
                global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
            ) -> ParseResult<'a, Parsed> {
                let mut iterations: usize = 0;
                let mut state = state;
                let mut args: Vec<ExpressionNode> = Vec::new();
                loop {
                    match closure::parse(state.clone(), global) {
                        Ok(ParseOk { result: __result, state: new_state, .. }) => {
                            args.extend(__result);
                            state = new_state;
                        }
                        Err(err) => {
                            state = state.record_error(err);
                            break;
                        }
                    }
                    iterations += 1;
                }
                Ok(ParseOk { result: args, state })
            }
            pub type Parsed = Vec<ExpressionNode>;
        }
        #[inline(always)]
        pub fn parse<'a, TT: ParseTracer>(
            state: ParseState<'a>,
            global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
        ) -> ParseResult<'a, Parsed> {
            let ParseOk { state, .. } = parse_Whitespace(state, &mut *global)
                .and_then(|ParseOk { state, .. }| parse_character_literal(state, '('))
                .discard_result()?;
            let ParseOk { result: mut args, state } = parse_Whitespace(state, &mut *global)
                .and_then(|ParseOk { state, .. }| parse_ExpressionNode(state, &mut *global))
                .map_inner(|result| vec![result])?;
            let ParseOk { result: extend_args_with, state } = part_2::parse(state, global)?;
            args.extend(extend_args_with);
            let ParseOk { state, .. } = parse_Whitespace(state.clone(), &mut *global)
                .and_then(|ParseOk { state, .. }| parse_character_literal(state, ','))
                .discard_result()
                .or_else(|err| Ok(ParseOk { result: (), state: state.record_error(err) }))?;
            let ParseOk { state, .. } = parse_Whitespace(state, &mut *global)
                .and_then(|ParseOk { state, .. }| parse_character_literal(state, ')'))
                .discard_result()?;
            Ok(ParseOk { result: args, state })
        }
        pub type Parsed = Vec<ExpressionNode>;
    }
    #[inline]
    pub(super) fn parse_FunctionArgs<'a, TT: ParseTracer>(
        state: ParseState<'a>,
        global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
    ) -> ParseResult<'a, FunctionArgs> {
        global.tracer.print_trace_start(&state, "FunctionArgs");
        let result = {
            let result = FunctionArgs_impl::parse(state, global)?.map(|r| super::FunctionArgs { args: r });
            Ok(result)
        };
        global.tracer.print_trace_result(&result);
        result
    }
    mod ValueNode_impl {
        use super::*;
        #[inline(always)]
        pub fn parse<'a, TT: ParseTracer>(
            state: ParseState<'a>,
            global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
        ) -> ParseResult<'a, Parsed> {
            ChoiceHelper::new(state)
                .choice(|state| {
                    parse_Whitespace(state, &mut *global)
                        .and_then(|ParseOk { state, .. }| parse_BooleanNode(state, global))
                        .map_inner(Parsed__override::BooleanNode)
                })
                .choice(|state| {
                    parse_Whitespace(state, &mut *global)
                        .and_then(|ParseOk { state, .. }| parse_DecimalNode(state, global))
                        .map_inner(Parsed__override::DecimalNode)
                })
                .choice(|state| {
                    parse_Whitespace(state, &mut *global)
                        .and_then(|ParseOk { state, .. }| parse_IntegerNode(state, global))
                        .map_inner(Parsed__override::IntegerNode)
                })
                .choice(|state| {
                    parse_Whitespace(state, &mut *global)
                        .and_then(|ParseOk { state, .. }| parse_StringNode(state, global))
                        .map_inner(Parsed__override::StringNode)
                })
                .choice(|state| {
                    parse_Whitespace(state, &mut *global)
                        .and_then(|ParseOk { state, .. }| parse_NamespaceNode(state, global))
                        .map_inner(Parsed__override::NamespaceNode)
                })
                .end()
        }
        pub type Parsed = Parsed__override;
        use super::ValueNode as Parsed__override;
    }
    #[inline]
    pub(super) fn parse_ValueNode<'a, TT: ParseTracer>(
        state: ParseState<'a>,
        global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
    ) -> ParseResult<'a, ValueNode> {
        global.tracer.print_trace_start(&state, "ValueNode");
        let result = {
            let result = ValueNode_impl::parse(state, global)?;
            Ok(result)
        };
        global.tracer.print_trace_result(&result);
        result
    }
    mod SlotL_impl {
        use super::*;
        #[inline(always)]
        pub fn parse<'a, TT: ParseTracer>(
            state: ParseState<'a>,
            global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
        ) -> ParseResult<'a, Parsed> {
            let ParseOk { state, .. } = parse_string_literal(state, "{%").discard_result()?;
            let ParseOk { result: trim, state } = parse_TrimMode(state.clone(), &mut *global)
                .map_inner(Some)
                .or_else(|err| Ok(ParseOk { result: Default::default(), state: state.record_error(err) }))?;
            Ok(ParseOk { result: trim, state })
        }
        pub type Parsed = Option<TrimMode>;
    }
    #[inline]
    pub(super) fn parse_SlotL<'a, TT: ParseTracer>(
        state: ParseState<'a>,
        global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
    ) -> ParseResult<'a, SlotL> {
        global.tracer.print_trace_start(&state, "SlotL");
        let result = {
            let result = SlotL_impl::parse(state.clone(), global)?
                .map_with_state(|r, new_state| super::SlotL { trim: r, position: state.range_until(new_state) });
            Ok(result)
        };
        global.tracer.print_trace_result(&result);
        result
    }
    impl PegPosition for SlotL {
        fn position(&self) -> &std::ops::Range<usize> {
            &self.position
        }
    }
    mod SlotR_impl {
        use super::*;
        #[inline(always)]
        pub fn parse<'a, TT: ParseTracer>(
            state: ParseState<'a>,
            global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
        ) -> ParseResult<'a, Parsed> {
            let ParseOk { result: trim, state } = parse_TrimMode(state.clone(), &mut *global)
                .map_inner(Some)
                .or_else(|err| Ok(ParseOk { result: Default::default(), state: state.record_error(err) }))?;
            let ParseOk { state, .. } = parse_string_literal(state, "%}").discard_result()?;
            Ok(ParseOk { result: trim, state })
        }
        pub type Parsed = Option<TrimMode>;
    }
    #[inline]
    pub(super) fn parse_SlotR<'a, TT: ParseTracer>(
        state: ParseState<'a>,
        global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
    ) -> ParseResult<'a, SlotR> {
        global.tracer.print_trace_start(&state, "SlotR");
        let result = {
            let result = SlotR_impl::parse(state.clone(), global)?
                .map_with_state(|r, new_state| super::SlotR { trim: r, position: state.range_until(new_state) });
            Ok(result)
        };
        global.tracer.print_trace_result(&result);
        result
    }
    impl PegPosition for SlotR {
        fn position(&self) -> &std::ops::Range<usize> {
            &self.position
        }
    }
    #[inline]
    pub(super) fn parse_TrimMode<'a, TT: ParseTracer>(
        state: ParseState<'a>,
        global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
    ) -> ParseResult<'a, TrimMode> {
        if let Ok(result) = parse_character_literal(state.clone(), '_') {
            return Ok(result);
        }
        if let Ok(result) = parse_character_literal(state.clone(), '-') {
            return Ok(result);
        }
        if let Ok(result) = parse_character_literal(state.clone(), '~') {
            return Ok(result);
        }
        if let Ok(result) = parse_character_literal(state.clone(), '=') {
            return Ok(result);
        }
        if let Ok(result) = parse_character_literal(state.clone(), '!') {
            return Ok(result);
        }
        Err(state.report_error(ParseErrorSpecifics::ExpectedCharacterClass { name: "TrimMode" }))
    }
    mod NamespaceNode_impl {
        use super::*;
        mod part_1 {
            use super::*;
            mod optional {
                use super::*;
                #[inline(always)]
                pub fn parse<'a, TT: ParseTracer>(
                    state: ParseState<'a>,
                    global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
                ) -> ParseResult<'a, Parsed> {
                    let ParseOk { state, .. } = parse_Whitespace(state, &mut *global)
                        .and_then(|ParseOk { state, .. }| parse_string_literal(state, "::"))
                        .discard_result()?;
                    let ParseOk { result: mut path, state } = parse_Whitespace(state, &mut *global)
                        .and_then(|ParseOk { state, .. }| parse_IdentifierNode(state, &mut *global))
                        .map_inner(|result| vec![result])?;
                    Ok(ParseOk { result: path, state })
                }
                pub type Parsed = Vec<IdentifierNode>;
            }
            #[inline(always)]
            pub fn parse<'a, TT: ParseTracer>(
                state: ParseState<'a>,
                global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
            ) -> ParseResult<'a, Parsed> {
                optional::parse(state.clone(), global)
                    .or_else(|err| Ok(ParseOk { result: Default::default(), state: state.record_error(err) }))
            }
            pub type Parsed = Vec<IdentifierNode>;
        }
        #[inline(always)]
        pub fn parse<'a, TT: ParseTracer>(
            state: ParseState<'a>,
            global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
        ) -> ParseResult<'a, Parsed> {
            let ParseOk { result: mut path, state } = parse_Whitespace(state, &mut *global)
                .and_then(|ParseOk { state, .. }| parse_IdentifierNode(state, &mut *global))
                .map_inner(|result| vec![result])?;
            let ParseOk { result: extend_path_with, state } = part_1::parse(state, global)?;
            path.extend(extend_path_with);
            Ok(ParseOk { result: path, state })
        }
        pub type Parsed = Vec<IdentifierNode>;
    }
    #[inline]
    pub(super) fn parse_NamespaceNode<'a, TT: ParseTracer>(
        state: ParseState<'a>,
        global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
    ) -> ParseResult<'a, NamespaceNode> {
        global.tracer.print_trace_start(&state, "NamespaceNode");
        let result = {
            let result = NamespaceNode_impl::parse(state.clone(), global)?
                .map_with_state(|r, new_state| super::NamespaceNode { path: r, position: state.range_until(new_state) });
            Ok(result)
        };
        global.tracer.print_trace_result(&result);
        result
    }
    impl PegPosition for NamespaceNode {
        fn position(&self) -> &std::ops::Range<usize> {
            &self.position
        }
    }
    mod IdentifierNode_impl {
        use super::*;
        mod part_1 {
            use super::*;
            mod closure {
                use super::*;
            }
            #[inline(always)]
            pub fn parse<'a, TT: ParseTracer>(
                state: ParseState<'a>,
                global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
            ) -> ParseResult<'a, Parsed> {
                let mut iterations: usize = 0;
                let mut state = state;
                loop {
                    match ChoiceHelper::new(state.clone())
                        .choice(|state| parse_XID_CONTINUE(state, &mut *global).discard_result())
                        .choice(|state| parse_character_literal(state, '-').discard_result())
                        .end()
                    {
                        Ok(ParseOk { result: __result, state: new_state, .. }) => {
                            state = new_state;
                        }
                        Err(err) => {
                            state = state.record_error(err);
                            break;
                        }
                    }
                    iterations += 1;
                }
                Ok(ParseOk { result: (), state })
            }
            pub type Parsed = ();
        }
        #[inline(always)]
        pub fn parse<'a, TT: ParseTracer>(
            state: ParseState<'a>,
            global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
        ) -> ParseResult<'a, Parsed> {
            let ParseOk { state, .. } = ChoiceHelper::new(state)
                .choice(|state| parse_XID_START(state, &mut *global).discard_result())
                .choice(|state| parse_character_literal(state, '_').discard_result())
                .choice(|state| parse_character_literal(state, '-').discard_result())
                .end()?;
            let ParseOk { state, .. } = part_1::parse(state, global)?;
            Ok(ParseOk { result: (), state })
        }
        pub type Parsed = ();
    }
    #[inline]
    pub(super) fn parse_IdentifierNode<'a, TT: ParseTracer>(
        state: ParseState<'a>,
        global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
    ) -> ParseResult<'a, IdentifierNode> {
        global.tracer.print_trace_start(&state, "IdentifierNode");
        let result = {
            let result = IdentifierNode_impl::parse(state.clone(), global)?.map_with_state(|_, new_state| {
                let string = state.slice_until(new_state).to_string();
                IdentifierNode { string, position: state.range_until(new_state) }
            });
            Ok(result)
        };
        global.tracer.print_trace_result(&result);
        result
    }
    impl PegPosition for IdentifierNode {
        fn position(&self) -> &std::ops::Range<usize> {
            &self.position
        }
    }
    #[inline]
    pub(super) fn parse_XID_START<'a, TT: ParseTracer>(
        state: ParseState<'a>,
        global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
    ) -> ParseResult<'a, XID_START> {
        if let Some(c) = state.s().chars().next() {
            if !unicode_ident::is_xid_start(c) {
                return Err(state.report_error(ParseErrorSpecifics::ExpectedCharacterClass { name: "XID_START" }));
            }
        }
        else {
            return Err(state.report_error(ParseErrorSpecifics::ExpectedCharacterClass { name: "XID_START" }));
        }
        if let Ok(result) = parse_char(state.clone(), global) {
            return Ok(result);
        }
        Err(state.report_error(ParseErrorSpecifics::ExpectedCharacterClass { name: "XID_START" }))
    }
    #[inline]
    pub(super) fn parse_XID_CONTINUE<'a, TT: ParseTracer>(
        state: ParseState<'a>,
        global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
    ) -> ParseResult<'a, XID_CONTINUE> {
        if let Some(c) = state.s().chars().next() {
            if !unicode_ident::is_xid_continue(c) {
                return Err(state.report_error(ParseErrorSpecifics::ExpectedCharacterClass { name: "XID_CONTINUE" }));
            }
        }
        else {
            return Err(state.report_error(ParseErrorSpecifics::ExpectedCharacterClass { name: "XID_CONTINUE" }));
        }
        if let Ok(result) = parse_char(state.clone(), global) {
            return Ok(result);
        }
        Err(state.report_error(ParseErrorSpecifics::ExpectedCharacterClass { name: "XID_CONTINUE" }))
    }
    mod BooleanNode_impl {
        use super::*;
        #[inline(always)]
        pub fn parse<'a, TT: ParseTracer>(
            state: ParseState<'a>,
            global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
        ) -> ParseResult<'a, Parsed> {
            ChoiceHelper::new(state)
                .choice(|state| {
                    parse_Whitespace(state, &mut *global)
                        .and_then(|ParseOk { state, .. }| parse_string_literal(state, "true"))
                        .discard_result()
                })
                .choice(|state| {
                    parse_Whitespace(state, &mut *global)
                        .and_then(|ParseOk { state, .. }| parse_string_literal(state, "false"))
                        .discard_result()
                })
                .end()
        }
        pub type Parsed = ();
    }
    #[inline]
    pub(super) fn parse_BooleanNode<'a, TT: ParseTracer>(
        state: ParseState<'a>,
        global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
    ) -> ParseResult<'a, BooleanNode> {
        global.tracer.print_trace_start(&state, "BooleanNode");
        let result = {
            let result = BooleanNode_impl::parse(state.clone(), global)?.map_with_state(|_, new_state| {
                let string = state.slice_until(new_state).to_string();
                BooleanNode { string, position: state.range_until(new_state) }
            });
            Ok(result)
        };
        global.tracer.print_trace_result(&result);
        result
    }
    impl PegPosition for BooleanNode {
        fn position(&self) -> &std::ops::Range<usize> {
            &self.position
        }
    }
    mod IntegerNode_impl {
        use super::*;
        mod closure {
            use super::*;
        }
        #[inline(always)]
        pub fn parse<'a, TT: ParseTracer>(
            state: ParseState<'a>,
            global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
        ) -> ParseResult<'a, Parsed> {
            let mut iterations: usize = 0;
            let mut state = state;
            loop {
                match parse_Whitespace(state.clone(), &mut *global)
                    .and_then(|ParseOk { state, .. }| parse_character_range(state, '0', '9'))
                    .discard_result()
                {
                    Ok(ParseOk { result: __result, state: new_state, .. }) => {
                        state = new_state;
                    }
                    Err(err) => {
                        state = state.record_error(err);
                        break;
                    }
                }
                iterations += 1;
            }
            if iterations == 0 {
                return Err(state.report_farthest_error());
            }
            Ok(ParseOk { result: (), state })
        }
        pub type Parsed = ();
    }
    #[inline]
    pub(super) fn parse_IntegerNode<'a, TT: ParseTracer>(
        state: ParseState<'a>,
        global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
    ) -> ParseResult<'a, IntegerNode> {
        global.tracer.print_trace_start(&state, "IntegerNode");
        let result = {
            let result = IntegerNode_impl::parse(state.clone(), global)?.map_with_state(|_, new_state| {
                let string = state.slice_until(new_state).to_string();
                IntegerNode { string, position: state.range_until(new_state) }
            });
            Ok(result)
        };
        global.tracer.print_trace_result(&result);
        result
    }
    impl PegPosition for IntegerNode {
        fn position(&self) -> &std::ops::Range<usize> {
            &self.position
        }
    }
    mod DecimalNode_impl {
        use super::*;
        mod choice_0 {
            use super::*;
            mod part_0 {
                use super::*;
                mod closure {
                    use super::*;
                }
                #[inline(always)]
                pub fn parse<'a, TT: ParseTracer>(
                    state: ParseState<'a>,
                    global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
                ) -> ParseResult<'a, Parsed> {
                    let mut iterations: usize = 0;
                    let mut state = state;
                    loop {
                        match parse_Whitespace(state.clone(), &mut *global)
                            .and_then(|ParseOk { state, .. }| parse_character_range(state, '0', '9'))
                            .discard_result()
                        {
                            Ok(ParseOk { result: __result, state: new_state, .. }) => {
                                state = new_state;
                            }
                            Err(err) => {
                                state = state.record_error(err);
                                break;
                            }
                        }
                        iterations += 1;
                    }
                    if iterations == 0 {
                        return Err(state.report_farthest_error());
                    }
                    Ok(ParseOk { result: (), state })
                }
                pub type Parsed = ();
            }
            mod part_1 {
                use super::*;
                mod optional {
                    use super::*;
                    mod part_1 {
                        use super::*;
                        mod closure {
                            use super::*;
                        }
                        #[inline(always)]
                        pub fn parse<'a, TT: ParseTracer>(
                            state: ParseState<'a>,
                            global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
                        ) -> ParseResult<'a, Parsed> {
                            let mut iterations: usize = 0;
                            let mut state = state;
                            loop {
                                match parse_Whitespace(state.clone(), &mut *global)
                                    .and_then(|ParseOk { state, .. }| parse_character_range(state, '0', '9'))
                                    .discard_result()
                                {
                                    Ok(ParseOk { result: __result, state: new_state, .. }) => {
                                        state = new_state;
                                    }
                                    Err(err) => {
                                        state = state.record_error(err);
                                        break;
                                    }
                                }
                                iterations += 1;
                            }
                            if iterations == 0 {
                                return Err(state.report_farthest_error());
                            }
                            Ok(ParseOk { result: (), state })
                        }
                        pub type Parsed = ();
                    }
                    #[inline(always)]
                    pub fn parse<'a, TT: ParseTracer>(
                        state: ParseState<'a>,
                        global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
                    ) -> ParseResult<'a, Parsed> {
                        let ParseOk { state, .. } = parse_Whitespace(state, &mut *global)
                            .and_then(|ParseOk { state, .. }| parse_character_literal(state, '.'))
                            .discard_result()?;
                        let ParseOk { state, .. } = part_1::parse(state, global)?;
                        Ok(ParseOk { result: (), state })
                    }
                    pub type Parsed = ();
                }
                #[inline(always)]
                pub fn parse<'a, TT: ParseTracer>(
                    state: ParseState<'a>,
                    global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
                ) -> ParseResult<'a, Parsed> {
                    optional::parse(state.clone(), global)
                        .or_else(|err| Ok(ParseOk { result: (), state: state.record_error(err) }))
                }
                pub type Parsed = ();
            }
            mod part_2 {
                use super::*;
                mod optional {
                    use super::*;
                    mod part_2 {
                        use super::*;
                        mod closure {
                            use super::*;
                        }
                        #[inline(always)]
                        pub fn parse<'a, TT: ParseTracer>(
                            state: ParseState<'a>,
                            global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
                        ) -> ParseResult<'a, Parsed> {
                            let mut iterations: usize = 0;
                            let mut state = state;
                            loop {
                                match parse_Whitespace(state.clone(), &mut *global)
                                    .and_then(|ParseOk { state, .. }| parse_character_range(state, '0', '9'))
                                    .discard_result()
                                {
                                    Ok(ParseOk { result: __result, state: new_state, .. }) => {
                                        state = new_state;
                                    }
                                    Err(err) => {
                                        state = state.record_error(err);
                                        break;
                                    }
                                }
                                iterations += 1;
                            }
                            if iterations == 0 {
                                return Err(state.report_farthest_error());
                            }
                            Ok(ParseOk { result: (), state })
                        }
                        pub type Parsed = ();
                    }
                    #[inline(always)]
                    pub fn parse<'a, TT: ParseTracer>(
                        state: ParseState<'a>,
                        global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
                    ) -> ParseResult<'a, Parsed> {
                        let ParseOk { state, .. } = ChoiceHelper::new(state)
                            .choice(|state| {
                                parse_Whitespace(state, &mut *global)
                                    .and_then(|ParseOk { state, .. }| parse_string_literal(state, "**"))
                                    .discard_result()
                            })
                            .choice(|state| {
                                parse_Whitespace(state, &mut *global)
                                    .and_then(|ParseOk { state, .. }| parse_character_literal(state, 'e'))
                                    .discard_result()
                            })
                            .choice(|state| {
                                parse_Whitespace(state, &mut *global)
                                    .and_then(|ParseOk { state, .. }| parse_character_literal(state, 'E'))
                                    .discard_result()
                            })
                            .end()?;
                        let ParseOk { state, .. } = ChoiceHelper::new(state.clone())
                            .choice(|state| {
                                parse_Whitespace(state, &mut *global)
                                    .and_then(|ParseOk { state, .. }| parse_character_literal(state, '+'))
                                    .discard_result()
                            })
                            .choice(|state| {
                                parse_Whitespace(state, &mut *global)
                                    .and_then(|ParseOk { state, .. }| parse_character_literal(state, '-'))
                                    .discard_result()
                            })
                            .end()
                            .or_else(|err| Ok(ParseOk { result: (), state: state.record_error(err) }))?;
                        let ParseOk { state, .. } = part_2::parse(state, global)?;
                        Ok(ParseOk { result: (), state })
                    }
                    pub type Parsed = ();
                }
                #[inline(always)]
                pub fn parse<'a, TT: ParseTracer>(
                    state: ParseState<'a>,
                    global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
                ) -> ParseResult<'a, Parsed> {
                    optional::parse(state.clone(), global)
                        .or_else(|err| Ok(ParseOk { result: (), state: state.record_error(err) }))
                }
                pub type Parsed = ();
            }
            #[inline(always)]
            pub fn parse<'a, TT: ParseTracer>(
                state: ParseState<'a>,
                global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
            ) -> ParseResult<'a, Parsed> {
                let ParseOk { state, .. } = part_0::parse(state, global)?;
                let ParseOk { state, .. } = part_1::parse(state, global)?;
                let ParseOk { state, .. } = part_2::parse(state, global)?;
                Ok(ParseOk { result: (), state })
            }
            pub type Parsed = ();
        }
        mod choice_1 {
            use super::*;
            mod part_1 {
                use super::*;
                mod closure {
                    use super::*;
                }
                #[inline(always)]
                pub fn parse<'a, TT: ParseTracer>(
                    state: ParseState<'a>,
                    global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
                ) -> ParseResult<'a, Parsed> {
                    let mut iterations: usize = 0;
                    let mut state = state;
                    loop {
                        match parse_Whitespace(state.clone(), &mut *global)
                            .and_then(|ParseOk { state, .. }| parse_character_range(state, '0', '9'))
                            .discard_result()
                        {
                            Ok(ParseOk { result: __result, state: new_state, .. }) => {
                                state = new_state;
                            }
                            Err(err) => {
                                state = state.record_error(err);
                                break;
                            }
                        }
                        iterations += 1;
                    }
                    if iterations == 0 {
                        return Err(state.report_farthest_error());
                    }
                    Ok(ParseOk { result: (), state })
                }
                pub type Parsed = ();
            }
            #[inline(always)]
            pub fn parse<'a, TT: ParseTracer>(
                state: ParseState<'a>,
                global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
            ) -> ParseResult<'a, Parsed> {
                let ParseOk { state, .. } = parse_Whitespace(state, &mut *global)
                    .and_then(|ParseOk { state, .. }| parse_character_literal(state, '.'))
                    .discard_result()?;
                let ParseOk { state, .. } = part_1::parse(state, global)?;
                Ok(ParseOk { result: (), state })
            }
            pub type Parsed = ();
        }
        #[inline(always)]
        pub fn parse<'a, TT: ParseTracer>(
            state: ParseState<'a>,
            global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
        ) -> ParseResult<'a, Parsed> {
            ChoiceHelper::new(state)
                .choice(|state| choice_0::parse(state, global))
                .choice(|state| choice_1::parse(state, global))
                .end()
        }
        pub type Parsed = ();
    }
    #[inline]
    pub(super) fn parse_DecimalNode<'a, TT: ParseTracer>(
        state: ParseState<'a>,
        global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
    ) -> ParseResult<'a, DecimalNode> {
        global.tracer.print_trace_start(&state, "DecimalNode");
        let result = {
            let result = DecimalNode_impl::parse(state.clone(), global)?.map_with_state(|_, new_state| {
                let string = state.slice_until(new_state).to_string();
                DecimalNode { string, position: state.range_until(new_state) }
            });
            Ok(result)
        };
        global.tracer.print_trace_result(&result);
        result
    }
    impl PegPosition for DecimalNode {
        fn position(&self) -> &std::ops::Range<usize> {
            &self.position
        }
    }
    mod UnicodeText_impl {
        use super::*;
        mod closure {
            use super::*;
            mod part_0 {
                use super::*;
                mod negative_lookahead {
                    use super::*;
                    #[inline(always)]
                    pub fn parse<'a, TT: ParseTracer>(
                        state: ParseState<'a>,
                        global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
                    ) -> ParseResult<'a, Parsed> {
                        ChoiceHelper::new(state)
                            .choice(|state| {
                                parse_Whitespace(state, &mut *global)
                                    .and_then(|ParseOk { state, .. }| parse_string_literal(state, "{%"))
                                    .discard_result()
                            })
                            .choice(|state| {
                                parse_Whitespace(state, &mut *global)
                                    .and_then(|ParseOk { state, .. }| parse_string_literal(state, "{#"))
                                    .discard_result()
                            })
                            .end()
                    }
                    pub type Parsed = ();
                }
                #[inline(always)]
                pub fn parse<'a, TT: ParseTracer>(
                    state: ParseState<'a>,
                    global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
                ) -> ParseResult<'a, Parsed> {
                    match negative_lookahead::parse(state.clone(), global) {
                        Ok(_) => Err(state.report_error(ParseErrorSpecifics::NegativeLookaheadFailed)),
                        Err(_) => Ok(ParseOk { result: (), state }),
                    }
                }
                pub type Parsed = ();
            }
            #[inline(always)]
            pub fn parse<'a, TT: ParseTracer>(
                state: ParseState<'a>,
                global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
            ) -> ParseResult<'a, Parsed> {
                let ParseOk { state, .. } = part_0::parse(state, global)?;
                let ParseOk { state, .. } = parse_Whitespace(state, &mut *global)
                    .and_then(|ParseOk { state, .. }| parse_char(state, &mut *global))
                    .discard_result()?;
                Ok(ParseOk { result: (), state })
            }
            pub type Parsed = ();
        }
        #[inline(always)]
        pub fn parse<'a, TT: ParseTracer>(
            state: ParseState<'a>,
            global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
        ) -> ParseResult<'a, Parsed> {
            let mut iterations: usize = 0;
            let mut state = state;
            loop {
                match closure::parse(state.clone(), global) {
                    Ok(ParseOk { result: __result, state: new_state, .. }) => {
                        state = new_state;
                    }
                    Err(err) => {
                        state = state.record_error(err);
                        break;
                    }
                }
                iterations += 1;
            }
            if iterations == 0 {
                return Err(state.report_farthest_error());
            }
            Ok(ParseOk { result: (), state })
        }
        pub type Parsed = ();
    }
    #[inline]
    pub(super) fn parse_UnicodeText<'a, TT: ParseTracer>(
        state: ParseState<'a>,
        global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
    ) -> ParseResult<'a, UnicodeText> {
        global.tracer.print_trace_start(&state, "UnicodeText");
        let result = {
            let result = UnicodeText_impl::parse(state.clone(), global)?.map_with_state(|_, new_state| {
                let string = state.slice_until(new_state).to_string();
                UnicodeText { string, position: state.range_until(new_state) }
            });
            Ok(result)
        };
        global.tracer.print_trace_result(&result);
        result
    }
    impl PegPosition for UnicodeText {
        fn position(&self) -> &std::ops::Range<usize> {
            &self.position
        }
    }
    mod StringNode_impl {
        use super::*;
        mod choice_0 {
            use super::*;
            mod part_1 {
                use super::*;
                mod closure {
                    use super::*;
                    mod part_0 {
                        use super::*;
                        mod negative_lookahead {
                            use super::*;
                            #[inline(always)]
                            pub fn parse<'a, TT: ParseTracer>(
                                state: ParseState<'a>,
                                global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
                            ) -> ParseResult<'a, Parsed> {
                                parse_DQ(state, &mut *global).discard_result()
                            }
                            pub type Parsed = ();
                        }
                        #[inline(always)]
                        pub fn parse<'a, TT: ParseTracer>(
                            state: ParseState<'a>,
                            global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
                        ) -> ParseResult<'a, Parsed> {
                            match negative_lookahead::parse(state.clone(), global) {
                                Ok(_) => Err(state.report_error(ParseErrorSpecifics::NegativeLookaheadFailed)),
                                Err(_) => Ok(ParseOk { result: (), state }),
                            }
                        }
                        pub type Parsed = ();
                    }
                    #[inline(always)]
                    pub fn parse<'a, TT: ParseTracer>(
                        state: ParseState<'a>,
                        global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
                    ) -> ParseResult<'a, Parsed> {
                        let ParseOk { state, .. } = part_0::parse(state, global)?;
                        let ParseOk { result: mut body, state } =
                            parse_StringItem(state, &mut *global).map_inner(|result| vec![result])?;
                        Ok(ParseOk { result: body, state })
                    }
                    pub type Parsed = Vec<StringItem>;
                }
                #[inline(always)]
                pub fn parse<'a, TT: ParseTracer>(
                    state: ParseState<'a>,
                    global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
                ) -> ParseResult<'a, Parsed> {
                    let mut iterations: usize = 0;
                    let mut state = state;
                    let mut body: Vec<StringItem> = Vec::new();
                    loop {
                        match closure::parse(state.clone(), global) {
                            Ok(ParseOk { result: __result, state: new_state, .. }) => {
                                body.extend(__result);
                                state = new_state;
                            }
                            Err(err) => {
                                state = state.record_error(err);
                                break;
                            }
                        }
                        iterations += 1;
                    }
                    Ok(ParseOk { result: body, state })
                }
                pub type Parsed = Vec<StringItem>;
            }
            #[inline(always)]
            pub fn parse<'a, TT: ParseTracer>(
                state: ParseState<'a>,
                global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
            ) -> ParseResult<'a, Parsed> {
                let ParseOk { result: dq, state } = parse_DQ(state, &mut *global).map_inner(Some)?;
                let ParseOk { result: mut body, state } = part_1::parse(state, global)?;
                let ParseOk { state, .. } = parse_DQ(state, &mut *global).discard_result()?;
                Ok(ParseOk { result: Parsed { dq, body }, state })
            }
            pub struct Parsed {
                pub dq: Option<DQ>,
                pub body: Vec<StringItem>,
            }
        }
        mod choice_1 {
            use super::*;
            mod part_1 {
                use super::*;
                mod closure {
                    use super::*;
                    mod part_0 {
                        use super::*;
                        mod negative_lookahead {
                            use super::*;
                            #[inline(always)]
                            pub fn parse<'a, TT: ParseTracer>(
                                state: ParseState<'a>,
                                global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
                            ) -> ParseResult<'a, Parsed> {
                                parse_SQ(state, &mut *global).discard_result()
                            }
                            pub type Parsed = ();
                        }
                        #[inline(always)]
                        pub fn parse<'a, TT: ParseTracer>(
                            state: ParseState<'a>,
                            global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
                        ) -> ParseResult<'a, Parsed> {
                            match negative_lookahead::parse(state.clone(), global) {
                                Ok(_) => Err(state.report_error(ParseErrorSpecifics::NegativeLookaheadFailed)),
                                Err(_) => Ok(ParseOk { result: (), state }),
                            }
                        }
                        pub type Parsed = ();
                    }
                    #[inline(always)]
                    pub fn parse<'a, TT: ParseTracer>(
                        state: ParseState<'a>,
                        global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
                    ) -> ParseResult<'a, Parsed> {
                        let ParseOk { state, .. } = part_0::parse(state, global)?;
                        let ParseOk { result: mut body, state } =
                            parse_StringItem(state, &mut *global).map_inner(|result| vec![result])?;
                        Ok(ParseOk { result: body, state })
                    }
                    pub type Parsed = Vec<StringItem>;
                }
                #[inline(always)]
                pub fn parse<'a, TT: ParseTracer>(
                    state: ParseState<'a>,
                    global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
                ) -> ParseResult<'a, Parsed> {
                    let mut iterations: usize = 0;
                    let mut state = state;
                    let mut body: Vec<StringItem> = Vec::new();
                    loop {
                        match closure::parse(state.clone(), global) {
                            Ok(ParseOk { result: __result, state: new_state, .. }) => {
                                body.extend(__result);
                                state = new_state;
                            }
                            Err(err) => {
                                state = state.record_error(err);
                                break;
                            }
                        }
                        iterations += 1;
                    }
                    Ok(ParseOk { result: body, state })
                }
                pub type Parsed = Vec<StringItem>;
            }
            #[inline(always)]
            pub fn parse<'a, TT: ParseTracer>(
                state: ParseState<'a>,
                global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
            ) -> ParseResult<'a, Parsed> {
                let ParseOk { result: sq, state } = parse_SQ(state, &mut *global).map_inner(Some)?;
                let ParseOk { result: mut body, state } = part_1::parse(state, global)?;
                let ParseOk { state, .. } = parse_SQ(state, &mut *global).discard_result()?;
                Ok(ParseOk { result: Parsed { body, sq }, state })
            }
            pub struct Parsed {
                pub body: Vec<StringItem>,
                pub sq: Option<SQ>,
            }
        }
        #[inline(always)]
        pub fn parse<'a, TT: ParseTracer>(
            state: ParseState<'a>,
            global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
        ) -> ParseResult<'a, Parsed> {
            ChoiceHelper::new(state)
                .choice(|state| choice_0::parse(state, global).map_inner(|r| Parsed { dq: r.dq, body: r.body, sq: None }))
                .choice(|state| choice_1::parse(state, global).map_inner(|r| Parsed { dq: None, body: r.body, sq: r.sq }))
                .end()
        }
        pub struct Parsed {
            pub dq: Option<DQ>,
            pub body: Vec<StringItem>,
            pub sq: Option<SQ>,
        }
    }
    #[inline]
    pub(super) fn parse_StringNode<'a, TT: ParseTracer>(
        state: ParseState<'a>,
        global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
    ) -> ParseResult<'a, StringNode> {
        global.tracer.print_trace_start(&state, "StringNode");
        let result = {
            let result = StringNode_impl::parse(state.clone(), global)?.map_with_state(|r, new_state| super::StringNode {
                dq: r.dq,
                body: r.body,
                sq: r.sq,
                position: state.range_until(new_state),
            });
            Ok(result)
        };
        global.tracer.print_trace_result(&result);
        result
    }
    impl PegPosition for StringNode {
        fn position(&self) -> &std::ops::Range<usize> {
            &self.position
        }
    }
    mod StringItem_impl {
        use super::*;
        #[inline(always)]
        pub fn parse<'a, TT: ParseTracer>(
            state: ParseState<'a>,
            global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
        ) -> ParseResult<'a, Parsed> {
            ChoiceHelper::new(state)
                .choice(|state| parse_EscapeUnicode(state, global).map_inner(Parsed__override::EscapeUnicode))
                .choice(|state| parse_EscapeOther(state, global).map_inner(Parsed__override::EscapeOther))
                .choice(|state| parse_char(state, global).map_inner(Parsed__override::char))
                .end()
        }
        pub type Parsed = Parsed__override;
        use super::StringItem as Parsed__override;
    }
    #[inline]
    pub(super) fn parse_StringItem<'a, TT: ParseTracer>(
        state: ParseState<'a>,
        global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
    ) -> ParseResult<'a, StringItem> {
        global.tracer.print_trace_start(&state, "StringItem");
        let result = {
            let result = StringItem_impl::parse(state, global)?;
            Ok(result)
        };
        global.tracer.print_trace_result(&result);
        result
    }
    mod SQ_impl {
        use super::*;
        #[inline(always)]
        pub fn parse<'a, TT: ParseTracer>(
            state: ParseState<'a>,
            global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
        ) -> ParseResult<'a, Parsed> {
            parse_Whitespace(state, &mut *global)
                .and_then(|ParseOk { state, .. }| parse_character_literal(state, '\''))
                .discard_result()
        }
        pub type Parsed = ();
    }
    #[inline]
    pub(super) fn parse_SQ<'a, TT: ParseTracer>(
        state: ParseState<'a>,
        global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
    ) -> ParseResult<'a, SQ> {
        global.tracer.print_trace_start(&state, "SQ");
        let result = {
            let result = SQ_impl::parse(state, global)?.map(|r| super::SQ {});
            Ok(result)
        };
        global.tracer.print_trace_result(&result);
        result
    }
    mod DQ_impl {
        use super::*;
        #[inline(always)]
        pub fn parse<'a, TT: ParseTracer>(
            state: ParseState<'a>,
            global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
        ) -> ParseResult<'a, Parsed> {
            parse_Whitespace(state, &mut *global)
                .and_then(|ParseOk { state, .. }| parse_character_literal(state, '"'))
                .discard_result()
        }
        pub type Parsed = ();
    }
    #[inline]
    pub(super) fn parse_DQ<'a, TT: ParseTracer>(
        state: ParseState<'a>,
        global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
    ) -> ParseResult<'a, DQ> {
        global.tracer.print_trace_start(&state, "DQ");
        let result = {
            let result = DQ_impl::parse(state, global)?.map(|r| super::DQ {});
            Ok(result)
        };
        global.tracer.print_trace_result(&result);
        result
    }
    mod EscapeOther_impl {
        use super::*;
        #[inline(always)]
        pub fn parse<'a, TT: ParseTracer>(
            state: ParseState<'a>,
            global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
        ) -> ParseResult<'a, Parsed> {
            let ParseOk { state, .. } = parse_Whitespace(state, &mut *global)
                .and_then(|ParseOk { state, .. }| parse_character_literal(state, '\\'))
                .discard_result()?;
            let ParseOk { result: _override, state } =
                parse_Whitespace(state, &mut *global).and_then(|ParseOk { state, .. }| parse_char(state, global))?;
            Ok(ParseOk { result: _override, state })
        }
        pub type Parsed = char;
        use super::EscapeOther as Parsed__override;
    }
    #[inline]
    pub(super) fn parse_EscapeOther<'a, TT: ParseTracer>(
        state: ParseState<'a>,
        global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
    ) -> ParseResult<'a, EscapeOther> {
        global.tracer.print_trace_start(&state, "EscapeOther");
        let result = {
            let result = EscapeOther_impl::parse(state, global)?;
            Ok(result)
        };
        global.tracer.print_trace_result(&result);
        result
    }
    mod EscapeUnicode_impl {
        use super::*;
        #[inline(always)]
        pub fn parse<'a, TT: ParseTracer>(
            state: ParseState<'a>,
            global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
        ) -> ParseResult<'a, Parsed> {
            let ParseOk { state, .. } = parse_Whitespace(state, &mut *global)
                .and_then(|ParseOk { state, .. }| parse_character_literal(state, '\\'))
                .discard_result()?;
            let ParseOk { state, .. } = parse_Whitespace(state, &mut *global)
                .and_then(|ParseOk { state, .. }| parse_character_literal(state, 'u'))
                .discard_result()?;
            Ok(ParseOk { result: (), state })
        }
        pub type Parsed = ();
    }
    #[inline]
    pub(super) fn parse_EscapeUnicode<'a, TT: ParseTracer>(
        state: ParseState<'a>,
        global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
    ) -> ParseResult<'a, EscapeUnicode> {
        global.tracer.print_trace_start(&state, "EscapeUnicode");
        let result = {
            let result = EscapeUnicode_impl::parse(state, global)?.map(|r| super::EscapeUnicode {});
            Ok(result)
        };
        global.tracer.print_trace_result(&result);
        result
    }
    mod Comment_impl {
        use super::*;
        mod part_1 {
            use super::*;
            mod closure {
                use super::*;
                mod choice_0 {
                    use super::*;
                    mod negative_lookahead {
                        use super::*;
                        #[inline(always)]
                        pub fn parse<'a, TT: ParseTracer>(
                            state: ParseState<'a>,
                            global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
                        ) -> ParseResult<'a, Parsed> {
                            parse_CommentR(state, &mut *global).discard_result()
                        }
                        pub type Parsed = ();
                    }
                    #[inline(always)]
                    pub fn parse<'a, TT: ParseTracer>(
                        state: ParseState<'a>,
                        global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
                    ) -> ParseResult<'a, Parsed> {
                        match negative_lookahead::parse(state.clone(), global) {
                            Ok(_) => Err(state.report_error(ParseErrorSpecifics::NegativeLookaheadFailed)),
                            Err(_) => Ok(ParseOk { result: (), state }),
                        }
                    }
                    pub type Parsed = ();
                }
                #[inline(always)]
                pub fn parse<'a, TT: ParseTracer>(
                    state: ParseState<'a>,
                    global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
                ) -> ParseResult<'a, Parsed> {
                    ChoiceHelper::new(state)
                        .choice(|state| choice_0::parse(state, global))
                        .choice(|state| parse_char(state, &mut *global).discard_result())
                        .end()
                }
                pub type Parsed = ();
            }
            #[inline(always)]
            pub fn parse<'a, TT: ParseTracer>(
                state: ParseState<'a>,
                global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
            ) -> ParseResult<'a, Parsed> {
                let mut iterations: usize = 0;
                let mut state = state;
                loop {
                    match closure::parse(state.clone(), global) {
                        Ok(ParseOk { result: __result, state: new_state, .. }) => {
                            state = new_state;
                        }
                        Err(err) => {
                            state = state.record_error(err);
                            break;
                        }
                    }
                    iterations += 1;
                }
                if iterations == 0 {
                    return Err(state.report_farthest_error());
                }
                Ok(ParseOk { result: (), state })
            }
            pub type Parsed = ();
        }
        #[inline(always)]
        pub fn parse<'a, TT: ParseTracer>(
            state: ParseState<'a>,
            global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
        ) -> ParseResult<'a, Parsed> {
            let ParseOk { result: left, state } = parse_CommentL(state, &mut *global)?;
            let ParseOk { state, .. } = part_1::parse(state, global)?;
            let ParseOk { result: right, state } = parse_CommentR(state, &mut *global)?;
            Ok(ParseOk { result: Parsed { left, right }, state })
        }
        pub struct Parsed {
            pub left: CommentL,
            pub right: CommentR,
        }
    }
    #[inline]
    pub(super) fn parse_Comment<'a, TT: ParseTracer>(
        state: ParseState<'a>,
        global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
    ) -> ParseResult<'a, Comment> {
        global.tracer.print_trace_start(&state, "Comment");
        let result = {
            let result = Comment_impl::parse(state, global)?.map(|r| super::Comment { left: r.left, right: r.right });
            Ok(result)
        };
        global.tracer.print_trace_result(&result);
        result
    }
    mod CommentL_impl {
        use super::*;
        #[inline(always)]
        pub fn parse<'a, TT: ParseTracer>(
            state: ParseState<'a>,
            global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
        ) -> ParseResult<'a, Parsed> {
            let ParseOk { state, .. } = parse_string_literal(state, "{#").discard_result()?;
            let ParseOk { result: trim, state } = parse_TrimMode(state.clone(), &mut *global)
                .map_inner(Some)
                .or_else(|err| Ok(ParseOk { result: Default::default(), state: state.record_error(err) }))?;
            Ok(ParseOk { result: trim, state })
        }
        pub type Parsed = Option<TrimMode>;
    }
    #[inline]
    pub(super) fn parse_CommentL<'a, TT: ParseTracer>(
        state: ParseState<'a>,
        global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
    ) -> ParseResult<'a, CommentL> {
        global.tracer.print_trace_start(&state, "CommentL");
        let result = {
            let result = CommentL_impl::parse(state.clone(), global)?
                .map_with_state(|r, new_state| super::CommentL { trim: r, position: state.range_until(new_state) });
            Ok(result)
        };
        global.tracer.print_trace_result(&result);
        result
    }
    impl PegPosition for CommentL {
        fn position(&self) -> &std::ops::Range<usize> {
            &self.position
        }
    }
    mod CommentR_impl {
        use super::*;
        #[inline(always)]
        pub fn parse<'a, TT: ParseTracer>(
            state: ParseState<'a>,
            global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
        ) -> ParseResult<'a, Parsed> {
            let ParseOk { result: trim, state } = parse_TrimMode(state.clone(), &mut *global)
                .map_inner(Some)
                .or_else(|err| Ok(ParseOk { result: Default::default(), state: state.record_error(err) }))?;
            let ParseOk { state, .. } = parse_string_literal(state, "#}").discard_result()?;
            Ok(ParseOk { result: trim, state })
        }
        pub type Parsed = Option<TrimMode>;
    }
    #[inline]
    pub(super) fn parse_CommentR<'a, TT: ParseTracer>(
        state: ParseState<'a>,
        global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
    ) -> ParseResult<'a, CommentR> {
        global.tracer.print_trace_start(&state, "CommentR");
        let result = {
            let result = CommentR_impl::parse(state.clone(), global)?
                .map_with_state(|r, new_state| super::CommentR { trim: r, position: state.range_until(new_state) });
            Ok(result)
        };
        global.tracer.print_trace_result(&result);
        result
    }
    impl PegPosition for CommentR {
        fn position(&self) -> &std::ops::Range<usize> {
            &self.position
        }
    }
}
