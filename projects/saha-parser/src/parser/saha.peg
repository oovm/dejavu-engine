@export
SahaParser = parsed:SahaStatementNodes $;

SahaStatementNodes = { statements:SahaStatement };

SahaStatement =
	@:Comment |
	@:UnicodeText |
	@:SlotFor |
	@:SlotIf |
	@:SlotExpressionNode
;


SlotIf = start:SlotIfStart body:SahaStatementNodes [else:SlotElse empty:SahaStatementNodes] end:EndIf;

SlotIfStart = left:SlotL "if" value:ValueNode right:SlotR;

SlotElse = left:SlotL "else" right:SlotR;

SlotEndIf = left:SlotL end:EndIf right:SlotR;

@no_skip_ws
EndIf = 'end' [['-'|'_'] "if"];





SlotFor = start:SlotForStart body:SahaStatementNodes [else:SlotElse empty:SahaStatementNodes] end:SlotEndFor;

SlotForStart = left:SlotL "for" pattern:ValueNode "in" expression:ValueNode right:SlotR;

SlotEndFor = left:SlotL end:EndFor right:SlotR;

@no_skip_ws
EndFor = 'end' [['-'|'_'] "for"];




SlotExpressionNode = left:SlotL value:ValueNode right:SlotR;

ValueNode =
	@:SpecialNode |
	@:NumberNode |
	@:IdentifierNode
;

@no_skip_ws
SlotL = "{%" [trim:TrimMode];

@no_skip_ws
SlotR = [trim:TrimMode] "%}";



@char
TrimMode = '_' | '-' | '=';

@string
@position
SpecialNode = 'null' | 'true' | 'false';

@string
@position
@no_skip_ws
IdentifierNode = (XID_START | '_') {XID_CONTINUE};

@char
@check(unicode_ident::is_xid_start)
XID_START = char;

@char
@check(unicode_ident::is_xid_continue)
XID_CONTINUE = char;



@position
@string
NumberNode = NumberNodeEx;

@extern(crate::utils::maybe_number)
NumberNodeEx;

@position
@string
UnicodeText = UnicodeTextEx;

@extern(crate::utils::unicode_text)
UnicodeTextEx;

@no_skip_ws
Comment = left:CommentL {!CommentR|char}+ right:CommentR;

@no_skip_ws
CommentL = "{#" [trim:TrimMode];

@no_skip_ws
CommentR = [trim:TrimMode] "#}";
