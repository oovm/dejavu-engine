@export
SahaParser = parsed:SahaStatementNodes $;

SahaStatementNodes = { statements:SahaStatement };

SahaStatement =
	@:Comment |
	@:SlotFor |
	@:SlotExpressionNode |
	@:UnicodeText
;

SlotFor = start:SlotForStart inner:SahaStatementNodes end:EndNode;

SlotForStart = left:SlotL "for" value:ValueNode "in" value:ValueNode right:SlotR;

SlotElse = left:SlotL "else" right:SlotR;

SlotExpressionNode = left:SlotL value:ValueNode right:SlotR;

ValueNode =
	@:IdentifierNode |
	@:NumberNode |
	@:SpecialNode
;

@no_skip_ws
SlotL = "{%" [trim:TrimMode];

@no_skip_ws
SlotR = [trim:TrimMode] "%}";

EndNode = left:SlotL EndWord right:SlotR;

@no_skip_ws
EndWord = 'end' ['-'|'_'] ["if" | "for" | "filter"];

@char
TrimMode = '_' | '-' | '=';

@string
@position
SpecialNode = 'null' | 'default' | 'true' | 'false';

@string
@position
@no_skip_ws
IdentifierNode = (XID_START | '_') {XID_CONTINUE};

@char
@check(unicode_ident::is_xid_start)
XID_START = char;

@char
@check(unicode_ident::is_xid_continue)
XID_CONTINUE = char;

@no_skip_ws
Whitespace = {Comment | UnicodeSpace};

@position
@string
NumberNode = NumberNodeEx;

@extern(crate::utils::maybe_number)
NumberNodeEx;

@position
@string
UnicodeText = UnicodeTextEx;

@extern(crate::utils::unicode_text)
UnicodeTextEx;

@extern(crate::utils::unicode_whitespace)
UnicodeSpace;

@no_skip_ws
Comment = left:CommentL {!CommentR|char}+ right:CommentR;

@no_skip_ws
CommentL = "{#" [trim:TrimMode];

@no_skip_ws
CommentR = [trim:TrimMode] "#}";
