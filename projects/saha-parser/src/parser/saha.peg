@export
SahaParser = { statements:SahaStatements } $;

SahaStatements =
	@:SlotExpressionNode |
	@:UnicodeSpace |
	@:UnicodeText
;

SlotExpressionNode = left:SlotL value:IdentifierNode right:SlotR;




@no_skip_ws
SlotL = "{%" [trim:TrimMode];

@no_skip_ws
SlotR = [trim:TrimMode] "%}";



EndNode = left:SlotL EndWord right:SlotR;

@no_skip_ws
EndWord = 'end' ['-'|'_'] ["if" | "for"];

@char
TrimMode = '_' | '-' | '=';

@string
@position
SpecialNode = 'null' | 'default' | 'true' | 'false';

@string
@position
@no_skip_ws
IdentifierNode = (XID_START | '_') {XID_CONTINUE};

@char
@check(unicode_ident::is_xid_start)
XID_START = char;

@char
@check(unicode_ident::is_xid_continue)
XID_CONTINUE = char;

@no_skip_ws
Whitespace = {Comment | UnicodeSpace};


@extern(crate::utils::unicode_text)
UnicodeText;

@extern(crate::utils::unicode_whitespace)
UnicodeSpace;

@no_skip_ws
Comment = '#' {!'\n' char} '\n';

@no_skip_ws
CommentL = "{#" trim:TrimMode;

@no_skip_ws
CommentR = trim:TrimMode "#}";
