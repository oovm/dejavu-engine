// This file was generated by Peginator v0.3.0
// Hash of the grammar file: 028CA6949DA4DFE20861CFF206F4C4EACF52718585EF5C00F82B7C65027F5979
// Any changes to it will be lost on regeneration

#[derive(Debug, Clone)]
pub struct FunctionDef {
    pub name: Ident,
    pub param_list: ParamList,
    pub return_value: Option<Type>,
}
#[derive(Debug, Clone)]
pub struct ParamList {
    pub self_param: Option<SelfParam>,
    pub params: Vec<Param>,
}
#[derive(Debug, Clone)]
pub struct Param {
    pub name: Ident,
    pub typ: Type,
}
#[derive(Debug, Clone)]
pub struct SelfParam {
    pub ref_type: Option<ReferenceMarker>,
}
#[derive(Debug, Clone)]
pub struct Type {
    pub ref_type: Option<ReferenceMarker>,
    pub typename: Ident,
}
#[allow(non_camel_case_types)]
#[derive(Debug, Clone)]
pub enum ReferenceMarker {
    ImmutableReference(ImmutableReference),
    MutableReference(MutableReference),
}
#[derive(Debug, Clone)]
pub struct ImmutableReference;
#[derive(Debug, Clone)]
pub struct MutableReference;
pub type Ident = String;
impl peginator_generated::PegParser for FunctionDef {
    fn parse_advanced<T: peginator_generated::ParseTracer>(
        s: &str,
        settings: &peginator_generated::ParseSettings,
    ) -> Result<Self, peginator_generated::ParseError> {
        Ok(peginator_generated::parse_FunctionDef(
            peginator_generated::ParseState::new(s, settings),
            T::new(),
            &mut Default::default(),
        )?
        .result)
    }
}
#[allow(non_snake_case, unused_variables, unused_imports, unused_mut, dead_code)]
mod peginator_generated {
    use super::*;
    use peginator::runtime::*;
    pub use peginator::runtime::{IndentedTracer, ParseError, ParseSettings, ParseState, ParseTracer, PegParser, PegPosition};
    #[derive(Default)]
    pub struct ParseCache<'a> {
        _please_dont_complain: std::marker::PhantomData<&'a ()>,
    }
    mod FunctionDef_impl {
        use super::*;
        mod part_5 {
            use super::*;
            mod optional {
                use super::*;
                #[inline(always)]
                pub fn parse<'a>(
                    state: ParseState<'a>,
                    tracer: impl ParseTracer,
                    cache: &mut ParseCache<'a>,
                ) -> ParseResult<'a, Parsed> {
                    let ParseOk { state, .. } = parse_Whitespace(state, tracer, cache)
                        .and_then(|ParseOk { state, .. }| parse_string_literal(state, "->"))
                        .discard_result()?;
                    let ParseOk { result: return_value, state } = parse_Whitespace(state, tracer, cache)
                        .and_then(|ParseOk { state, .. }| parse_Type(state, tracer, cache))
                        .map_inner(Some)?;
                    Ok(ParseOk { result: return_value, state })
                }
                pub type Parsed = Option<Type>;
            }
            #[inline(always)]
            pub fn parse<'a>(
                state: ParseState<'a>,
                tracer: impl ParseTracer,
                cache: &mut ParseCache<'a>,
            ) -> ParseResult<'a, Parsed> {
                optional::parse(state.clone(), tracer, cache)
                    .or_else(|err| Ok(ParseOk { result: Default::default(), state: state.record_error(err) }))
            }
            pub type Parsed = Option<Type>;
        }
        #[inline(always)]
        pub fn parse<'a>(
            state: ParseState<'a>,
            tracer: impl ParseTracer,
            cache: &mut ParseCache<'a>,
        ) -> ParseResult<'a, Parsed> {
            let ParseOk { state, .. } = parse_Whitespace(state, tracer, cache)
                .and_then(|ParseOk { state, .. }| parse_string_literal(state, "fn"))
                .discard_result()?;
            let ParseOk { result: name, state } =
                parse_Whitespace(state, tracer, cache).and_then(|ParseOk { state, .. }| parse_Ident(state, tracer, cache))?;
            let ParseOk { state, .. } = parse_Whitespace(state, tracer, cache)
                .and_then(|ParseOk { state, .. }| parse_character_literal(state, '('))
                .discard_result()?;
            let ParseOk { result: param_list, state } = parse_Whitespace(state, tracer, cache)
                .and_then(|ParseOk { state, .. }| parse_ParamList(state, tracer, cache))?;
            let ParseOk { state, .. } = parse_Whitespace(state, tracer, cache)
                .and_then(|ParseOk { state, .. }| parse_character_literal(state, ')'))
                .discard_result()?;
            let ParseOk { result: return_value, state } = part_5::parse(state, tracer, cache)?;
            Ok(ParseOk { result: Parsed { name, param_list, return_value }, state })
        }
        pub struct Parsed {
            pub name: Ident,
            pub param_list: ParamList,
            pub return_value: Option<Type>,
        }
        #[inline(always)]
        pub fn rule_parser<'a>(
            state: ParseState<'a>,
            tracer: impl ParseTracer,
            cache: &mut ParseCache<'a>,
        ) -> ParseResult<'a, super::FunctionDef> {
            let result = parse(state, tracer, cache)?.map(|r| super::FunctionDef {
                name: r.name,
                param_list: r.param_list,
                return_value: r.return_value,
            });
            Ok(result)
        }
    }
    #[inline]
    pub(super) fn parse_FunctionDef<'a>(
        state: ParseState<'a>,
        tracer: impl ParseTracer,
        cache: &mut ParseCache<'a>,
    ) -> ParseResult<'a, FunctionDef> {
        tracer.run_traced("FunctionDef", state, |state, tracer| FunctionDef_impl::rule_parser(state, tracer, cache))
    }
    mod ParamList_impl {
        use super::*;
        mod choice_0 {
            use super::*;
            mod part_1 {
                use super::*;
                mod closure {
                    use super::*;
                    #[inline(always)]
                    pub fn parse<'a>(
                        state: ParseState<'a>,
                        tracer: impl ParseTracer,
                        cache: &mut ParseCache<'a>,
                    ) -> ParseResult<'a, Parsed> {
                        let ParseOk { state, .. } = parse_Whitespace(state, tracer, cache)
                            .and_then(|ParseOk { state, .. }| parse_character_literal(state, ','))
                            .discard_result()?;
                        let ParseOk { result: mut params, state } = parse_Whitespace(state, tracer, cache)
                            .and_then(|ParseOk { state, .. }| parse_Param(state, tracer, cache))
                            .map_inner(|result| vec![result])?;
                        Ok(ParseOk { result: params, state })
                    }
                    pub type Parsed = Vec<Param>;
                }
                #[inline(always)]
                pub fn parse<'a>(
                    state: ParseState<'a>,
                    tracer: impl ParseTracer,
                    cache: &mut ParseCache<'a>,
                ) -> ParseResult<'a, Parsed> {
                    let mut iterations: usize = 0;
                    let mut state = state;
                    let mut params: Vec<Param> = Vec::new();
                    loop {
                        match closure::parse(state.clone(), tracer, cache) {
                            Ok(ParseOk { result: __result, state: new_state, .. }) => {
                                params.extend(__result);
                                state = new_state;
                            }
                            Err(err) => {
                                state = state.record_error(err);
                                break;
                            }
                        }
                        iterations += 1;
                    }
                    Ok(ParseOk { result: params, state })
                }
                pub type Parsed = Vec<Param>;
            }
            #[inline(always)]
            pub fn parse<'a>(
                state: ParseState<'a>,
                tracer: impl ParseTracer,
                cache: &mut ParseCache<'a>,
            ) -> ParseResult<'a, Parsed> {
                let ParseOk { result: self_param, state } = parse_Whitespace(state, tracer, cache)
                    .and_then(|ParseOk { state, .. }| parse_SelfParam(state, tracer, cache))
                    .map_inner(Some)?;
                let ParseOk { result: mut params, state } = part_1::parse(state, tracer, cache)?;
                Ok(ParseOk { result: Parsed { self_param, params }, state })
            }
            pub struct Parsed {
                pub self_param: Option<SelfParam>,
                pub params: Vec<Param>,
            }
        }
        mod choice_1 {
            use super::*;
            mod part_1 {
                use super::*;
                mod closure {
                    use super::*;
                    #[inline(always)]
                    pub fn parse<'a>(
                        state: ParseState<'a>,
                        tracer: impl ParseTracer,
                        cache: &mut ParseCache<'a>,
                    ) -> ParseResult<'a, Parsed> {
                        let ParseOk { state, .. } = parse_Whitespace(state, tracer, cache)
                            .and_then(|ParseOk { state, .. }| parse_character_literal(state, ','))
                            .discard_result()?;
                        let ParseOk { result: mut params, state } = parse_Whitespace(state, tracer, cache)
                            .and_then(|ParseOk { state, .. }| parse_Param(state, tracer, cache))
                            .map_inner(|result| vec![result])?;
                        Ok(ParseOk { result: params, state })
                    }
                    pub type Parsed = Vec<Param>;
                }
                #[inline(always)]
                pub fn parse<'a>(
                    state: ParseState<'a>,
                    tracer: impl ParseTracer,
                    cache: &mut ParseCache<'a>,
                ) -> ParseResult<'a, Parsed> {
                    let mut iterations: usize = 0;
                    let mut state = state;
                    let mut params: Vec<Param> = Vec::new();
                    loop {
                        match closure::parse(state.clone(), tracer, cache) {
                            Ok(ParseOk { result: __result, state: new_state, .. }) => {
                                params.extend(__result);
                                state = new_state;
                            }
                            Err(err) => {
                                state = state.record_error(err);
                                break;
                            }
                        }
                        iterations += 1;
                    }
                    Ok(ParseOk { result: params, state })
                }
                pub type Parsed = Vec<Param>;
            }
            #[inline(always)]
            pub fn parse<'a>(
                state: ParseState<'a>,
                tracer: impl ParseTracer,
                cache: &mut ParseCache<'a>,
            ) -> ParseResult<'a, Parsed> {
                let ParseOk { result: mut params, state } = parse_Whitespace(state, tracer, cache)
                    .and_then(|ParseOk { state, .. }| parse_Param(state, tracer, cache))
                    .map_inner(|result| vec![result])?;
                let ParseOk { result: extend_params_with, state } = part_1::parse(state, tracer, cache)?;
                params.extend(extend_params_with);
                Ok(ParseOk { result: params, state })
            }
            pub type Parsed = Vec<Param>;
        }
        #[inline(always)]
        pub fn parse<'a>(
            mut state: ParseState<'a>,
            tracer: impl ParseTracer,
            cache: &mut ParseCache<'a>,
        ) -> ParseResult<'a, Parsed> {
            ChoiceHelper::new(state)
                .choice(|state| {
                    choice_0::parse(state.clone(), tracer, cache)
                        .map_inner(|r| Parsed { self_param: r.self_param, params: r.params })
                })
                .choice(|state| {
                    choice_1::parse(state.clone(), tracer, cache).map_inner(|r| Parsed { self_param: None, params: r })
                })
                .choice(|state| {
                    Ok(ParseOk { result: (), state }).map_inner(|r| Parsed { self_param: None, params: Vec::new() })
                })
                .end()
        }
        pub struct Parsed {
            pub self_param: Option<SelfParam>,
            pub params: Vec<Param>,
        }
        #[inline(always)]
        pub fn rule_parser<'a>(
            state: ParseState<'a>,
            tracer: impl ParseTracer,
            cache: &mut ParseCache<'a>,
        ) -> ParseResult<'a, super::ParamList> {
            let result = parse(state, tracer, cache)?.map(|r| super::ParamList { self_param: r.self_param, params: r.params });
            Ok(result)
        }
    }
    #[inline]
    pub(super) fn parse_ParamList<'a>(
        state: ParseState<'a>,
        tracer: impl ParseTracer,
        cache: &mut ParseCache<'a>,
    ) -> ParseResult<'a, ParamList> {
        tracer.run_traced("ParamList", state, |state, tracer| ParamList_impl::rule_parser(state, tracer, cache))
    }
    mod Param_impl {
        use super::*;
        #[inline(always)]
        pub fn parse<'a>(
            state: ParseState<'a>,
            tracer: impl ParseTracer,
            cache: &mut ParseCache<'a>,
        ) -> ParseResult<'a, Parsed> {
            let ParseOk { result: name, state } =
                parse_Whitespace(state, tracer, cache).and_then(|ParseOk { state, .. }| parse_Ident(state, tracer, cache))?;
            let ParseOk { state, .. } = parse_Whitespace(state, tracer, cache)
                .and_then(|ParseOk { state, .. }| parse_character_literal(state, ':'))
                .discard_result()?;
            let ParseOk { result: typ, state } =
                parse_Whitespace(state, tracer, cache).and_then(|ParseOk { state, .. }| parse_Type(state, tracer, cache))?;
            Ok(ParseOk { result: Parsed { name, typ }, state })
        }
        pub struct Parsed {
            pub name: Ident,
            pub typ: Type,
        }
        #[inline(always)]
        pub fn rule_parser<'a>(
            state: ParseState<'a>,
            tracer: impl ParseTracer,
            cache: &mut ParseCache<'a>,
        ) -> ParseResult<'a, super::Param> {
            let result = parse(state, tracer, cache)?.map(|r| super::Param { name: r.name, typ: r.typ });
            Ok(result)
        }
    }
    #[inline]
    pub(super) fn parse_Param<'a>(
        state: ParseState<'a>,
        tracer: impl ParseTracer,
        cache: &mut ParseCache<'a>,
    ) -> ParseResult<'a, Param> {
        tracer.run_traced("Param", state, |state, tracer| Param_impl::rule_parser(state, tracer, cache))
    }
    mod SelfParam_impl {
        use super::*;
        #[inline(always)]
        pub fn parse<'a>(
            state: ParseState<'a>,
            tracer: impl ParseTracer,
            cache: &mut ParseCache<'a>,
        ) -> ParseResult<'a, Parsed> {
            let ParseOk { result: ref_type, state } = parse_Whitespace(state.clone(), tracer, cache)
                .and_then(|ParseOk { state, .. }| parse_ReferenceMarker(state, tracer, cache))
                .map_inner(Some)
                .or_else(|err| Ok(ParseOk { result: Default::default(), state: state.record_error(err) }))?;
            let ParseOk { state, .. } = parse_Whitespace(state, tracer, cache)
                .and_then(|ParseOk { state, .. }| parse_string_literal(state, "self"))
                .discard_result()?;
            Ok(ParseOk { result: ref_type, state })
        }
        pub type Parsed = Option<ReferenceMarker>;
        #[inline(always)]
        pub fn rule_parser<'a>(
            state: ParseState<'a>,
            tracer: impl ParseTracer,
            cache: &mut ParseCache<'a>,
        ) -> ParseResult<'a, super::SelfParam> {
            let result = parse(state, tracer, cache)?.map(|r| super::SelfParam { ref_type: r });
            Ok(result)
        }
    }
    #[inline]
    pub(super) fn parse_SelfParam<'a>(
        state: ParseState<'a>,
        tracer: impl ParseTracer,
        cache: &mut ParseCache<'a>,
    ) -> ParseResult<'a, SelfParam> {
        tracer.run_traced("SelfParam", state, |state, tracer| SelfParam_impl::rule_parser(state, tracer, cache))
    }
    mod Type_impl {
        use super::*;
        #[inline(always)]
        pub fn parse<'a>(
            state: ParseState<'a>,
            tracer: impl ParseTracer,
            cache: &mut ParseCache<'a>,
        ) -> ParseResult<'a, Parsed> {
            let ParseOk { result: ref_type, state } = parse_Whitespace(state.clone(), tracer, cache)
                .and_then(|ParseOk { state, .. }| parse_ReferenceMarker(state, tracer, cache))
                .map_inner(Some)
                .or_else(|err| Ok(ParseOk { result: Default::default(), state: state.record_error(err) }))?;
            let ParseOk { result: typename, state } =
                parse_Whitespace(state, tracer, cache).and_then(|ParseOk { state, .. }| parse_Ident(state, tracer, cache))?;
            Ok(ParseOk { result: Parsed { ref_type, typename }, state })
        }
        pub struct Parsed {
            pub ref_type: Option<ReferenceMarker>,
            pub typename: Ident,
        }
        #[inline(always)]
        pub fn rule_parser<'a>(
            state: ParseState<'a>,
            tracer: impl ParseTracer,
            cache: &mut ParseCache<'a>,
        ) -> ParseResult<'a, super::Type> {
            let result = parse(state, tracer, cache)?.map(|r| super::Type { ref_type: r.ref_type, typename: r.typename });
            Ok(result)
        }
    }
    #[inline]
    pub(super) fn parse_Type<'a>(
        state: ParseState<'a>,
        tracer: impl ParseTracer,
        cache: &mut ParseCache<'a>,
    ) -> ParseResult<'a, Type> {
        tracer.run_traced("Type", state, |state, tracer| Type_impl::rule_parser(state, tracer, cache))
    }
    mod ReferenceMarker_impl {
        use super::*;
        #[inline(always)]
        pub fn parse<'a>(
            mut state: ParseState<'a>,
            tracer: impl ParseTracer,
            cache: &mut ParseCache<'a>,
        ) -> ParseResult<'a, Parsed> {
            ChoiceHelper::new(state)
                .choice(|state| {
                    parse_Whitespace(state, tracer, cache)
                        .and_then(|ParseOk { state, .. }| parse_MutableReference(state, tracer, cache))
                        .map_inner(Parsed__override::MutableReference)
                })
                .choice(|state| {
                    parse_Whitespace(state, tracer, cache)
                        .and_then(|ParseOk { state, .. }| parse_ImmutableReference(state, tracer, cache))
                        .map_inner(Parsed__override::ImmutableReference)
                })
                .end()
        }
        pub type Parsed = Parsed__override;
        use super::ReferenceMarker as Parsed__override;
        #[inline(always)]
        pub fn rule_parser<'a>(
            state: ParseState<'a>,
            tracer: impl ParseTracer,
            cache: &mut ParseCache<'a>,
        ) -> ParseResult<'a, super::ReferenceMarker> {
            let result = parse(state, tracer, cache)?;
            Ok(result)
        }
    }
    #[inline]
    pub(super) fn parse_ReferenceMarker<'a>(
        state: ParseState<'a>,
        tracer: impl ParseTracer,
        cache: &mut ParseCache<'a>,
    ) -> ParseResult<'a, ReferenceMarker> {
        tracer.run_traced("ReferenceMarker", state, |state, tracer| ReferenceMarker_impl::rule_parser(state, tracer, cache))
    }
    mod ImmutableReference_impl {
        use super::*;
        #[inline(always)]
        pub fn parse<'a>(
            state: ParseState<'a>,
            tracer: impl ParseTracer,
            cache: &mut ParseCache<'a>,
        ) -> ParseResult<'a, Parsed> {
            parse_Whitespace(state, tracer, cache)
                .and_then(|ParseOk { state, .. }| parse_character_literal(state, '&'))
                .discard_result()
        }
        pub type Parsed = ();
        #[inline(always)]
        pub fn rule_parser<'a>(
            state: ParseState<'a>,
            tracer: impl ParseTracer,
            cache: &mut ParseCache<'a>,
        ) -> ParseResult<'a, super::ImmutableReference> {
            let result = parse(state, tracer, cache)?.map(|r| super::ImmutableReference {});
            Ok(result)
        }
    }
    #[inline]
    pub(super) fn parse_ImmutableReference<'a>(
        state: ParseState<'a>,
        tracer: impl ParseTracer,
        cache: &mut ParseCache<'a>,
    ) -> ParseResult<'a, ImmutableReference> {
        tracer
            .run_traced("ImmutableReference", state, |state, tracer| ImmutableReference_impl::rule_parser(state, tracer, cache))
    }
    mod MutableReference_impl {
        use super::*;
        #[inline(always)]
        pub fn parse<'a>(
            state: ParseState<'a>,
            tracer: impl ParseTracer,
            cache: &mut ParseCache<'a>,
        ) -> ParseResult<'a, Parsed> {
            let ParseOk { state, .. } = parse_Whitespace(state, tracer, cache)
                .and_then(|ParseOk { state, .. }| parse_character_literal(state, '&'))
                .discard_result()?;
            let ParseOk { state, .. } = parse_Whitespace(state, tracer, cache)
                .and_then(|ParseOk { state, .. }| parse_string_literal(state, "mut"))
                .discard_result()?;
            Ok(ParseOk { result: (), state })
        }
        pub type Parsed = ();
        #[inline(always)]
        pub fn rule_parser<'a>(
            state: ParseState<'a>,
            tracer: impl ParseTracer,
            cache: &mut ParseCache<'a>,
        ) -> ParseResult<'a, super::MutableReference> {
            let result = parse(state, tracer, cache)?.map(|r| super::MutableReference {});
            Ok(result)
        }
    }
    #[inline]
    pub(super) fn parse_MutableReference<'a>(
        state: ParseState<'a>,
        tracer: impl ParseTracer,
        cache: &mut ParseCache<'a>,
    ) -> ParseResult<'a, MutableReference> {
        tracer.run_traced("MutableReference", state, |state, tracer| MutableReference_impl::rule_parser(state, tracer, cache))
    }
    mod Ident_impl {
        use super::*;
        mod closure {
            use super::*;
        }
        #[inline(always)]
        pub fn parse<'a>(
            state: ParseState<'a>,
            tracer: impl ParseTracer,
            cache: &mut ParseCache<'a>,
        ) -> ParseResult<'a, Parsed> {
            let mut iterations: usize = 0;
            let mut state = state;
            loop {
                match ChoiceHelper::new(state.clone())
                    .choice(|state| parse_character_range(state, 'a', 'z').discard_result())
                    .choice(|state| parse_character_range(state, 'A', 'Z').discard_result())
                    .choice(|state| parse_character_literal(state, '_').discard_result())
                    .choice(|state| parse_character_range(state, '0', '9').discard_result())
                    .end()
                {
                    Ok(ParseOk { result: __result, state: new_state, .. }) => {
                        state = new_state;
                    }
                    Err(err) => {
                        state = state.record_error(err);
                        break;
                    }
                }
                iterations += 1;
            }
            Ok(ParseOk { result: (), state })
        }
        pub type Parsed = ();
        #[inline(always)]
        pub fn rule_parser<'a>(
            state: ParseState<'a>,
            tracer: impl ParseTracer,
            cache: &mut ParseCache<'a>,
        ) -> ParseResult<'a, Ident> {
            let result = parse(state.clone(), tracer, cache)?.map_with_state(|_, new_state| {
                let string = state.slice_until(new_state).to_string();
                string
            });
            Ok(result)
        }
    }
    #[inline]
    pub(super) fn parse_Ident<'a>(
        state: ParseState<'a>,
        tracer: impl ParseTracer,
        cache: &mut ParseCache<'a>,
    ) -> ParseResult<'a, Ident> {
        tracer.run_traced("Ident", state, |state, tracer| Ident_impl::rule_parser(state, tracer, cache))
    }
}
